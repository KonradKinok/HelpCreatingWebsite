<!DOCTYPE html><html lang="pl"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=Raleway:wght@100;300;700&family=Roboto:wght@300;400&display=swap" rel="stylesheet"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/modern-normalize/1.0.0/modern-normalize.min.css"><link rel="stylesheet" href="/HelpCreatingWebsite/index.c4a3a779.css"><link rel="stylesheet" href="/HelpCreatingWebsite/htmlReact/01-wprowadzenieDoReact.a7417870.css"><title>Nawigacja2</title></head><body class="body-container"> <header class="menu-sticky"> <nav class="nav-container">  <ul id="main-menu" class="nav-list-container"></ul> </nav> </header> <main class="main-container">  <section id="section1" class="text"> <article id="article1"> <h1>Moduł 5 - Zajęcia 10 - Nawigacja</h1> <h2>Nawigacja po programie</h2> <p> React Router pozwala wykonać nawigację nie tylko po kliknięciu w Link, ale również po określonym działaniu użytkownika, zdarzeniu lub efekcie, na przykład po kliknięciu na przycisk, po wysłaniu formularza, po wyniku zapytania HTTP i tym podobne. Dla przykładu wykorzystujemy proces logowania użytkownika w aplikacji. Po wysłaniu formularza na stronie logowania wykonujemy nawigację na stronie profilu użytkownika, ale tylko jeśli zapytanie HTTP zakończyło się sukcesem. </p> <p> Pierwszy sposób to hook useNavigate. Dostarcza nam funkcję navigate, do której przy wywołaniu przekazujemy ścieżkę określającą dokąd należy wykonać nawigację. Jest to imperatywny sposób, ale bardziej elastyczny i wymaga mniejszej ilości kodu. </p> <pre>
            src/pages/Login.jsx

            import { useNavigate } from "react-router-dom";

            export const Login = () => {
              const navigate = useNavigate();

              const handleSubmit = async values => {
                const response = await FakeAPI.login(values);
                if (response.success) {
                  navigate("/profile", { replace: true });
                }
              };

              return (
                &ltdiv>
                  &lth1>Login page&lt/h1>
                  &ltLoginForm onSubmit={handleSubmit} />
                &lt/div>
              );
            };
          </pre> <p> Zwróć uwagę na drugi, nieobowiązkowy argument funkcji navigate - to obiekt parametrów. Właściwość replace, domyślnie false, kontroluje, w jaki sposób zostanie dodany nowy zapis do stosu historii. Wróćmy do analogii ze stertą dokumentów. Domyślnie nowa kartka zostanie dodana na górze sterty, co w żaden sposób nie wpłynie na pozostałe karty. Jeżeli wskazać wartość true, to nowa karta podmieni tę, która jest na samym wierzchu. Wykorzystuje się to dość rzadko, na przykład przy logowaniu, aby użytkownik nie mógł powrócić przyciskiem "wróć" na stronę logowania po wejściu, ponieważ jest już w systemie i nie ma tam nic więcej do zrobienia. </p> </article> </section> </main> <footer class="footer"> <div class="footer-logo"> <img src="/HelpCreatingWebsite/konikMaly24x24Squoosh.989f9831.png" alt="logoImage" width="24"> <img src="/HelpCreatingWebsite/3KLogo.b575da86.png" alt="logoText"> </div> <div id="footer-title"> <p></p> </div> <div class="footer-date"> <p>17.06.2024r.</p> </div> </footer>  <script defer src="/HelpCreatingWebsite/htmlReact/01-wprowadzenieDoReact.ab3a5978.js"></script> </body></html>