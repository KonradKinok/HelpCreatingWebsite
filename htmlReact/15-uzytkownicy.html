<!DOCTYPE html><html lang="pl"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=Raleway:wght@100;300;700&family=Roboto:wght@300;400&display=swap" rel="stylesheet"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/modern-normalize/1.0.0/modern-normalize.min.css"><link rel="stylesheet" href="/HelpCreatingWebsite/index.066807ea.css"><link rel="stylesheet" href="/HelpCreatingWebsite/htmlReact/01-wprowadzenieDoReact.a7417870.css"><title>U偶ytkownicy</title></head><body class="body-container"> <header class="menu-sticky"> <nav class="nav-container">  <ul id="main-menu" class="nav-list-container"></ul> <ul id="this-page-menu" class="this-page-menu"></ul> </nav> </header> <main class="main-container">  <section id="1" class="text"> <h1>Modu 8 - Zajcia 15 - U偶ytkownicy</h1> <article id="1.1"> <h2>1.1 Konta</h2> <p> Absolutna wikszo aplikacji pozwala u偶ytkownikowi utworzy konto. Daje to front-endowi i back-endowi mo偶liwo rozr贸偶niania u偶ytkownik贸w. Dziki temu zarejestrowany u偶ytkownik mo偶e pracowa z danymi, kt贸re s dostpne tylko dla niego. Na przykad w aplikacji planera zada, ka偶dy zarejestrowany u偶ytkownik bdzie mia swoj odrbn list zada. </p> <div class="grow_up-img img-container"> <img src="/HelpCreatingWebsite/users.6f1f9039.png" alt=""> </div> <p> Opr贸cz tego aplikacja mo偶e posiada zamknite trasy, dostpne tylko dla zarejestrowanych u偶ytkownik贸w. Jeli u偶ytkownik nie wszed na swoje konto, przy pr贸bie odwiedzenia zamknitej trasy zostanie przekierowany na stron logowania albo rejestracji. </p> <div class="grow_up-img img-container"> <img src="/HelpCreatingWebsite/redirects.b05636d8.png" alt=""> </div> </article> </section> <section id="2" class="text"> <article id="2.1"> <h2>2.1 Uprawnienia dostpu</h2> <p> Proces weryfikacji uwierzytelnienia oraz sprawdzanie poziomu uprawnie dostpu do danych wykonuje si na backendzie i jest opisywany dwoma terminami. </p> <p> Uwierzytelnienie (authentication) - to proces sprawdzenia uprawnie dostpu u偶ytkownika (login/haso). Sprawdzenie poprawnoci danych u偶ytkownika drog por贸wnania wprowadzonego przez niego loginu/hasa z danymi zapisanymi w bazie danych. </p> <p> Autoryzacja (authorization) - to sprawdzenie uprawnie u偶ytkownika dla konkretnych zasob贸w. Uprawnieniami dostpu mo偶e by dowolna unikalna warto, kt贸r front-end przekazuje z ka偶dym zapytaniem HTTP do back-endu. </p> <div class="grow_up-img img-container"> <img src="/HelpCreatingWebsite/auth.c81f5a05.png" alt=""> </div> <p> Na przykad, podczas ka偶dego zapytania do zasobu my-api.com/tasks, system autoryzacji sprawdzi, czy u偶ytkownik ma prawo zwraca si do tego zasobu. W rezultacie zapytanie zwr贸ci status 200 lub 403. Uprawnienia dostpu do zasobu okrela si na podstawie obecnoci unikalnej wartoci w zapytaniu (tokenie). </p> </article> </section> <section id="3" class="text"> <article id="3.1"> <h2>3.1 JSON Web Token</h2> <p> Jeden z mechanizm贸w autoryzacji to JWT (JSON Web Token). Tokeny reprezentuj sob rodki autoryzacji dla ka偶dego zapytania od front-endu do back-endu. Tokeny tworzone s w back-endzie w oparciu o sekretny klucz (kt贸ry przechowywany jest na serwerze) i jakie unikalne dla u偶ytkownika dane, np. email . Token w rezultacie jest przechowywany na front-endzie i wykorzystywany do autoryzacji ka偶dego zapytania. </p> <p> Ka偶dy token to unikalny zaszyfrowany wiersz, kt贸ry zawiera trzy bloki: nag贸wek (header), zbi贸r p贸l (payload) i sygnatur. Pr贸ba podmiany danych w headerze lub payloadzie (przez kogo ze zymi zamiarami ) spowoduje uniewa偶nienie tokenu, gdy偶 jego sygnatura nie bdzie odpowiadaa pocztkowym wartociom. Mo偶liwoci wygenerowania nowej sygnatury nie ma, poniewa偶 tajny klucz szyfrowania znajduje si tylko na serwerze. </p> <div class="grow_up-img img-container"> <img src="/HelpCreatingWebsite/jwt.f8ef4083.png" alt=""> </div> </article> </section> <section id="4" class="text"> <article id="4.1"> <h2>4.1 Menad偶er zada</h2> <p> Przeanalizuj kompletny przykad aplikacji menad偶era zada, w kt贸rym dodana jest realizacja rejestracji, loginu, aktualizacji u偶ytkownika, przekierowania i pracy ze zbiorem chronionych danych. W przykadzie wykorzystuje si penowartociowy back-end, kt贸ry tworzy JWT dla ka偶dego u偶ytkownika. Za prac z u偶ytkownikiem i tokenem odpowiada cz statusu state.auth, przeanalizuj slice, operacj i selektory. </p> <p>Zanim jednak to zrobimy musimy wprowadzi na koniec kilka poj i bibliotek.</p> </article> <article id="4.2"> <h3>4.2 React Helmet</h3> <p> <a href="https://www.npmjs.com/package/react-helmet">React Helmet</a> pozwala nam na modyfikacj wszystkich waciwoci head dokumentu. Najprostszym przykadem wykorzystania tej biblioteki jest zmiana tytuu strony jako pole title w zale偶noci od Routingu. </p> <p> Nasza strona logowania nazwana Login.js wykorzystujca formularz LoginForm.jsx oraz React Helmet wyglda w nastpujcy spos贸b: </p> <pre>
            import { Helmet } from 'react-helmet';
            import { LoginForm } from 'components/LoginForm/LoginForm';

            export default function Login() {
              return (
                &ltdiv>
                  &ltHelmet>
                    &lttitle>Login&lt/title>
                  &lt/Helmet>
                  &ltLoginForm />
                &lt/div>
              );
            }
          </pre> </article> <article id="4.3"> <h3>4.3 Redux Persist</h3> <p> <a href="https://www.npmjs.com/package/redux-persist">Redux Persist</a> pozwala na przechowywanie informacji w Store tak偶e po odwie偶eniu strony. Najczeciej jest u偶ywany do przechowywania informacji o tokenie u偶ytkownika. Dziki temu, po odwie偶eniu strony u偶ytkownik nie musi si ponownie logowa - Redux Persist po odwie偶eniu/ponownym wejciu na stron odczyta zapisane wczeniej informacji w np localStorage. U偶ywajc tej biblioteki musimy zrobi zmiany w dw贸ch naszych plikach: </p> <pre>
            store.js
            import { configureStore } from "@reduxjs/toolkit";
            import {
              persistStore,
              persistReducer,
              FLUSH, REHYDRATE, PAUSE, PERSIST, PURGE, REGISTER,
            } from "redux-persist";
            **import storage from "redux-persist/lib/storage";**
            import { tasksReducer } from "./tasks/slice";
            import { authReducer } from "./auth/slice";

            // Persisting token field from auth slice to localstorage
            const authPersistConfig = {
              key: "auth",
              storage,
              whitelist: ["token"],
            };

            export const store = configureStore({
              reducer: {
                auth: persistReducer(authPersistConfig, authReducer),
                tasks: tasksReducer,
              },
              **middleware: (getDefaultMiddleware) =>
                getDefaultMiddleware({
                  serializableCheck: {
                    ignoredActions: [FLUSH, REHYDRATE, PAUSE, PERSIST, PURGE, REGISTER],
                  },
                }),
              devTools: process.env.NODE_ENV === "development",
            });

            export const persistor = persistStore(store);
          </pre> <p> Idc od g贸ry: importujemy persistStore, persistReducer oraz kilka dodatkowych akcji z redux-persist. Importujemy tak偶e storage - domylnie jest to localStorage. W celu u偶ycia innych miejsc do przechowywania informacji zapraszam do dokumentacji biblioteki. </p> <p>Nastpnie definujemy authPersistConfig, w kt贸rym definiujemy 3 istotne element:</p> <ul class="unnumbered-list-container"> <li>key - klucz o odpowiadajcej nazwie naszego reducera</li> <li> storage - miejsce, w kt贸rym biblioteka bdzie przechowywaa informacje pomidzy odwie偶eniami strony </li> <li> whitelist lub blacklist - <a href="https://www.npmjs.com/package/redux-persist#blacklist--whitelist">szczeg贸y dostpne w dokumentacji</a> </li> </ul> <p> Kolejne dwie zmiany dotycz ju偶 samej konfiguracji naszego store. Przede wszystkim u偶ywamy metody persistReducer do kt贸rej przekazujemy config oraz oryginalny reducer. Nastpnie definujemy middleware, w kt贸rym przekazujemy informacj na temat akcji, kt贸re redux-persist ma ignorowa podczas procesu zapisywania informacji do storage. Middleware to kawaek kodu, kt贸ry jest wykonywany "pomidzy" danymi akcjami u偶ytkownika - w naszym wypadku pomidzy wykonani dowolnej akcji. O middlewarach nauczycie si wicej podczas kursu Node.js. Ignorujemy kilka akcji celowo, poniewa偶 zale偶y nam na tym, by nasz kod zosta odwie偶any podczas wykonywania akcji przez u偶ytkownika, a nie podczas akcji, kt贸re redux-persist wykonuje. </p> <pre>
            index.js
            import React from 'react';
            import ReactDOM from 'react-dom/client';
            import { App } from 'components/App';
            import { BrowserRouter } from 'react-router-dom';
            import { PersistGate } from 'redux-persist/integration/react';
            import { Provider } from 'react-redux';
            import { store, persistor } from './redux/store';
            import 'modern-normalize';
            import './styles.css';

            ReactDOM.createRoot(document.getElementById('root')).render(
              &ltReact.StrictMode>
                &ltProvider store={store}>
                  **&ltPersistGate loading={null} persistor={persistor}>**
                    &ltBrowserRouter>
                      &ltApp />
                    &lt/BrowserRouter>
                  &lt/PersistGate>
                &lt/Provider>
              &lt/React.StrictMode>
            );
          </pre> <p> Do index.js zostay dodane pogrubione fragmenty kodu. PersistGate dodajemy w takim sam spos贸b jak dodajemy React.Context. Musimy zdefiniowa dwa argumenty: </p> <ul class="unnumbered-list-container"> <li> loading - komponent (lub null), kt贸ry si wywietli, podczas gdy biblioteka bdzie pr贸bowaa pobra pocztkowe dane </li> <li>persistor - wynik funkcji persistStore z naszego store.js</li> </ul> </article> <article id="4.4"> <h3>4.4 Auth</h3> <p> Poza akcjami Redux`owymi, kt贸re znajduj si w src/redux/auth potrzebujemy doda jeszcze kilka plik贸w: </p> <h4>Hook useAuth</h4> <pre>
            import { useSelector } from 'react-redux';
            import {
              selectUser,
              selectIsLoggedIn,
              selectIsRefreshing,
            } from 'redux/auth/selectors';

            export const useAuth = () => {
              const isLoggedIn = useSelector(selectIsLoggedIn);
              const isRefreshing = useSelector(selectIsRefreshing);
              const user = useSelector(selectUser);

              return {
                isLoggedIn,
                isRefreshing,
                user,
              };
            };
          </pre> <p> Hook ten pozwala nam w atwy spos贸b dosta si do wszystkich informacji o u偶ytkowniku. Bdziemy go wykorzystywa w kilku miejscach aplikacji. Jego g贸wnym zadaniem jest agregacja selektor贸w w jednym miejscu. </p> <h4>Komponenty PrivateRoute oraz RestrictedRoute</h4> <pre>
            import { Navigate } from 'react-router-dom';
            import { useAuth } from 'hooks';

            export const PrivateRoute = ({ component: Component, redirectTo = '/' }) => {
              const { isLoggedIn, isRefreshing } = useAuth();
              const shouldRedirect = !isLoggedIn && !isRefreshing;

              return shouldRedirect ? &ltNavigate to={redirectTo} /> : Component;
            };
          </pre> <p> Komponenty te odpowiedzialne s za dostp do naszych zasob贸w. Na podstawie hooka useAuth otrzymujemy informacje o u偶ytkowniku. Je偶eli u偶ytkownik jest zalogowany i spr贸buje wej na RestrictedRoute zostanie przekierowany na inny adres URL. Nie chcemy zalogowanemu u偶ytkownikowi dawa mo偶liwoci ponownego zalogowania si, bd藕 zarejestrowania. W przypadku PrivateRoute sprawa jest odwrotna: je偶eli u偶ytkownik nie jest zalogowany nale偶y go przekierowa na odpowiedni adres URL. </p> <pre>
            App.js
            import { useEffect, lazy } from 'react';
            import { useDispatch } from 'react-redux';
            import { Route, Routes } from 'react-router-dom';
            import { Layout } from './Layout';
            import { PrivateRoute } from './PrivateRoute';
            import { RestrictedRoute } from './RestrictedRoute';
            import { refreshUser } from 'redux/auth/operations';
            import { useAuth } from 'hooks';

            const HomePage = lazy(() => import('../pages/Home'));
            const RegisterPage = lazy(() => import('../pages/Register'));
            const LoginPage = lazy(() => import('../pages/Login'));
            const TasksPage = lazy(() => import('../pages/Tasks'));

            export const App = () => {
              const dispatch = useDispatch();
              const { isRefreshing } = useAuth();

              useEffect(() => {
                dispatch(refreshUser());
              }, [dispatch]);

              return isRefreshing ? (
                &ltb>Refreshing user...&lt/b>
              ) : (
                &ltRoutes>
                  &ltRoute path="/" element={&ltLayout />}>
                    &ltRoute index element={&ltHomePage />} />
                    &ltRoute
                      path="/register"
                      element={
                        &ltRestrictedRoute redirectTo="/tasks" component={&ltRegisterPage />} />
                      }
                    />
                    &ltRoute
                      path="/login"
                      element={
                        &ltRestrictedRoute redirectTo="/tasks" component={&ltLoginPage />} />
                      }
                    />
                    &ltRoute
                      path="/tasks"
                      element={
                        &ltPrivateRoute redirectTo="/login" component={&ltTasksPage />} />
                      }
                    />
                  &lt/Route>
                &lt/Routes>
              );
            };
          </pre> <p> Ostatnia rzecz to zmiany w App.js. Przede wszystkim definiujemy, kt贸re cie偶ki s Private i powinnimy przekierowa u偶ytkownik贸w na /login, a kt贸re s Restricted i powinnimy zalogowanych u偶ytkownik贸w kierowa na stron /tasks. </p> <p> <a href="https://codesandbox.io/p/sandbox/goit-textbook-lesson-15-16-auth-final-lvri7x?from-embed=">codesandbox.io</a> </p> </article> </section> <section id="5" class="text"> <article id="5.1"> <h2>5.1 Filmy</h2> <p> <a target="_blank" href="https://youtu.be/9HnQKzxPU6A">Zajcie Modu 8. U偶ytkownicy. cz.1</a> </p> <p> <a target="_blank" href="https://youtu.be/tMN1yAKuJbo">Zajcie Modu 8. U偶ytkownicy. cz.2</a> </p> </article> <article id="5.2"> <h2>5.2 Instalacja</h2> <p> <a target="_blank" href="https://www.npmjs.com/package/react-helmet">React Helmet</a> </p> <pre>
            npm install --save react-helmet
          </pre> <p> <a target="_blank" href="https://www.npmjs.com/package/redux-persist">Redux Persist</a> </p> <pre>
            npm install redux-persist
          </pre> </article></section> </main> <footer class="footer"> <div class="footer-logo"> <img src="/HelpCreatingWebsite/konikMaly24x24Squoosh.989f9831.png" alt="logoImage" width="24"> <img src="/HelpCreatingWebsite/3KLogo.b575da86.png" alt="logoText"> </div> <div id="footer-title"> <p></p> </div> <div class="footer-date"> <p>17.06.2024r.</p> </div> </footer>  <script defer src="/HelpCreatingWebsite/htmlReact/01-wprowadzenieDoReact.c0eaeeea.js"></script> </body></html>