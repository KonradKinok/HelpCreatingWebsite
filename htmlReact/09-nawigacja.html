<!DOCTYPE html><html lang="pl"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=Raleway:wght@100;300;700&family=Roboto:wght@300;400&display=swap" rel="stylesheet"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/modern-normalize/1.0.0/modern-normalize.min.css"><link rel="stylesheet" href="/HelpCreatingWebsite/index.c4a3a779.css"><link rel="stylesheet" href="/HelpCreatingWebsite/htmlReact/01-wprowadzenieDoReact.a7417870.css"><title>Nawigacja</title></head><body class="body-container"> <header class="menu-sticky"> <nav class="nav-container">  <ul id="main-menu" class="nav-list-container"></ul> </nav> </header> <main class="main-container">  <section id="section1" class="text"> <article id="article1"> <h1>ModuÅ‚ 5 - ZajÄ™cia 9 - Nawigacja</h1> <h2>Routing</h2> <p> Elementem wyrÃ³Å¼niajÄ…cym aplikacjÄ™ webowÄ…, w porÃ³wnaniu do desktopowej, jest obecnoÅ›Ä‡ URL. ZmieniajÄ…c go, uÅ¼ytkownik moÅ¼e wyÅ›wietlaÄ‡ kolejne czÄ™Å›ci aplikacji. UÅ¼ytkownik moÅ¼e zapisaÄ‡ dany adres w postaci zakÅ‚adki lub przesÅ‚aÄ‡ go do innego uÅ¼ytkownika, ktÃ³ry dziÄ™ki temu zobaczy ten sam interfejs (z wyjÄ…tkiem danych prywatnych). </p> <p>Routing - struktura nawigacji</p> <p>ÅšcieÅ¼ka / Route - pojedynczy element nawigacyjny</p> <p> Routing nie jest "miÅ‚ym dodatkiem" do aplikacji. Przeciwnie, strukturÄ™ nawigacji i zestaw podstron naleÅ¼y przemyÅ›leÄ‡ na samym poczÄ…tku. </p> </article> <article id="article2"> <h3>Struktura Å‚aÅ„cucha URL</h3> <p> AnalogiÄ… Å‚aÅ„cucha URL moÅ¼e byÄ‡ adres, pod ktÃ³rym mieszkasz: ulica, dom, mieszkanie. Dla kaÅ¼dego stanu interfejsu (tego co widzi uÅ¼ytkownik) powinien istnieÄ‡ adres URL. </p> <p> Przeanalizujmy z jakich czÄ™Å›ci moÅ¼e skÅ‚adaÄ‡ siÄ™ przykÅ‚adowy URL. </p> <div class="grow_up-img img-container"> <img src="/HelpCreatingWebsite/url-string.2d367099.jpg" alt=""> </div> <ul class="unnumbered-list-container"> <li>https:// - protokÃ³Å‚</li> <li>mysite.com/ - host</li> <li> books/e3q76gm9lzk - Å›cieÅ¼ka, to gdzie znajdujemy siÄ™ w aplikacji </li> <li> e3q76gm9lzk - parametr url. Parametry bywajÄ… dynamiczne lub statyczne </li> <li>? - symbol poczÄ…tku Å‚aÅ„cucha zapytania (search query)</li> <li> ?category=adventure&status=unread - Å‚aÅ„cuch zapytania (search query) </li> <li>category=adventure - para parametr=wartoÅ›Ä‡</li> <li>& - symbol "I", rozdziela parametry Å‚aÅ„cucha zapytania</li> <li>#comments - kotwica (hash), okreÅ›la poÅ‚oÅ¼enie na stronie</li> </ul> </article> <article id="article3"> <h3>Historia nawigacji</h3> <p> Historia nawigacji (przeglÄ…dania) zawiera informacje o historii naszego przeglÄ…dania danej zakÅ‚adki przeglÄ…darki. WykorzystujÄ…c wÅ‚aÅ›ciwoÅ›ci i metody HTML5 History API moÅ¼emy przechodziÄ‡ do tyÅ‚u i do przodu po historii uÅ¼ytkownika i manipulowaÄ‡ jego zawartoÅ›ciÄ…. </p> <p> JeÅ›li chcesz lepiej zrozumieÄ‡ React Router, po zapoznaniu siÄ™ z podstawowymi koncepcjami rekomendujemy wrÃ³ciÄ‡ i przeanalizowaÄ‡ artykuÅ‚ <a href="https://blog.pshrmn.com/a-little-bit-of-history/">A Little Bit of History.</a> </p> </article> <article id="article4"> <h3>Routing w React</h3> <p> W React nie ma wbudowanego moduÅ‚u routingu, dlatego najczÄ™Å›ciej wykorzystuje siÄ™ <a href="https://reactrouter.com/en/main">React Router</a>. Analogicznie jak React, dostarcza nam zestawu prymitywÃ³w do tworzenia interfejsu uÅ¼ytkownika. Zawiera rÃ³wnieÅ¼ zestaw hookÃ³w do tworzenia routingu, zarzÄ…dzania historiÄ… nawigacji uÅ¼ytkownika i wyÅ›wietlania rÃ³Å¼nych komponentÃ³w w zaleÅ¼noÅ›ci od obecnej wartoÅ›ci URL w Å‚aÅ„cuchu adresowym przeglÄ…darki. </p> <pre>
            npm install react-router-dom
          </pre> </article> </section> <section id="section2" class="text"> <article id="article1"> <h2>Komponent BrowserRouter</h2> <p> BrowserRouter - centrum sterowania routingiem, ktÃ³re kryje w sobie caÅ‚Ä… logikÄ™ wspÃ³Å‚pracy z historiÄ… przeglÄ…darki. Tworzy router i obiekt historii nawigacji, aby synchronizowaÄ‡ interfejs z adresem URL. WykorzystujÄ…c kontekst React, przekazuje informacjÄ™ o bieÅ¼Ä…cym stanie historii nawigacji wszystkim potomkom. Na poczÄ…tku wystarczy owinÄ…Ä‡ komponentem BrowserRouter caÅ‚Ä… aplikacjÄ™. </p> <p> Komponent BrowserRouter to Router, ktÃ³ry uÅ¼ywa interfejsu API historii HTML5 (pushState, replaceState i zdarzenie popstate), aby zapewniÄ‡ synchronizacjÄ™ interfejsu uÅ¼ytkownika z adresem URL. Dlatego teÅ¼ korzystamy juÅ¼ z rozbudowanego komponentu BrowserRouter. </p> <pre>
            src/index.js
            import { BrowserRouter } from "react-router-dom";

            ReactDOM.createRoot(document.getElementById("root")).render(
              &ltReact.StrictMode>
                &ltBrowserRouter>
                  &ltApp />
                &lt/BrowserRouter>
              &lt/React.StrictMode>
            );
          </pre> <p> W kolejnej czÄ™Å›ci moduÅ‚u przeanalizujemy jak opisywaÄ‡ routing aplikacji. </p> <p> Komponent BrowserRouter moÅ¼emy takÅ¼e zapisaÄ‡ uÅ¼ywajÄ…c nowego podejÅ›cia, z wykorzystaniem hookÃ³w i RouterProvider , natomiast jest to rozwiÄ…zanie jeszcze maÅ‚o popularne. </p> <pre>
            import {
              createBrowserRouter,
              createRoutesFromElements,
              Route,
              RouterProvider,
            } from "react-router-dom";

            const router = createBrowserRouter(
              createRoutesFromElements(
                &ltRoute path="/" element={&ltRoot />}>
                  &ltRoute path="dashboard" element={&ltDashboard />} />
                  {/* ... etc. */}
                &lt/Route>
              )
            );

            ReactDOM.createRoot(document.getElementById("root")).render(
              &ltReact.StrictMode>
                &ltRouterProvider router={router} />
              &lt/React.StrictMode>
            );
          </pre> <p> <a href="https://reactrouter.com/en/main/routers/picking-a-router">Jaki Router wybraÄ‡?</a> </p> </article> </section> <section id="section3" class="text"> <article id="article1"> <h2>Komponenty Route i Routes</h2> <p> Komponent Route pozwala powiÄ…zaÄ‡ okreÅ›lony URL z konkretnym komponentem. PrzykÅ‚adowo, jeÅ›li chcemy wyÅ›wietliÄ‡ komponent About, kiedy uÅ¼ytkownik przechodzi na Å›cieÅ¼kÄ™ /about, naleÅ¼y opisaÄ‡ takÄ… Å›cieÅ¼kÄ™ nastÄ™pujÄ…co: </p> <pre>
            &ltRoute path="/about" element={&ltAbout />} />
          </pre> <p> WartoÅ›ciÄ… propsu element moÅ¼e byÄ‡ dowolny, poprawny JSX, ale w praktyce wykorzystywane sÄ… zawsze komponenty. </p> <p> Komponent Route zawsze musi coÅ› wyrenderowaÄ‡: komponent wskazany w propsie element jeÅ›li path pokrywa siÄ™ z bieÅ¼Ä…cÄ… wartoÅ›ciÄ… segmentu pathname w polu adresowym przeglÄ…darki lub null, jeÅ›li siÄ™ nie pokrywa. </p> <p> MoÅ¼emy zdefinowaÄ‡ dowolnÄ… iloÅ›Ä‡ Å›cieÅ¼ek, ale minimum to jedna na kaÅ¼dÄ… stronÄ™ aplikacji. PrzypuÅ›Ä‡my, Å¼e tworzymy aplikacjÄ™ sklepu z odzieÅ¼Ä…: </p> <pre>
            src/components/App.jsx

            import { Routes, Route } from "react-router-dom";
            import Home from "path/to/pages/Home";
            import About from "path/to/pages/About";
            import Products from "path/to/pages/Products";

            export const App = () => {
              return (
                &ltdiv>
                  &ltRoutes>
                    &ltRoute path="/" element={&ltHome />} />
                    &ltRoute path="/about" element={&ltAbout />} />
                    &ltRoute path="/products" element={&ltProducts />} />
                  &lt/Routes>
                &lt/div>
              );
            };
          </pre> <p> GrupÄ™ Å›cieÅ¼ek musimy owinÄ…Ä‡ w komponent Routes, nawet jeÅ›li Å›cieÅ¼ka jest tylko jedna. Route nigdy nie moÅ¼e byÄ‡ wykorzystywany poza Routes. Komponent Routes odpowiada za logikÄ™ wyboru najlepiej pasujÄ…cego Route dla bieÅ¼Ä…cej wartoÅ›ci URL w polu adresowym przeglÄ…darki. </p> <p> Wiesz juÅ¼, Å¼e jednÄ… z konwencji struktury plikÃ³w w aplikacji jest zapisywanie wszystkich komponentÃ³w w folderze src/components. Komponent strony to rÃ³wnieÅ¼ zwykÅ‚y komponent React, ale dla wygody i ustrukturyzowania, takie komponenty przechowujemy oddzielnie w folderze src/pages </p> </article> <article id="article1"> <h3>Strona bÅ‚Ä™du nawigacji</h3> <p> BiorÄ…c pod uwagÄ™ dotychczasowy opis routingu sklepu internetowego, kiedy uÅ¼ytkownik przejdzie po odnoÅ›niku na adres URL /non-existing-route (lub na dowolny inny, ktÃ³ry nie istnieje w naszej aplikacji) - zobaczy pustÄ… zakÅ‚adkÄ™ przeglÄ…darki bez Å¼adnej zwartoÅ›ci. Dzieje siÄ™ tak, gdyÅ¼ Å¼aden z opisanych przez nas Route nie pasuje do tego URL. PowinniÅ›my informowaÄ‡ uÅ¼ytkownika o tym, Å¼e adres ktÃ³ry wybraÅ‚ nie istnieje (nie zostaÅ‚ znaleziony). W tym celu na samym koÅ„cu listy Å›cieÅ¼ek dodamy jeszcze jeden Route, ktÃ³ry bÄ™dzie pokrywaÅ‚ siÄ™ z dowolnym URL, ale zostanie wybrany tylko wtedy, gdy Å¼adna inna Å›cieÅ¼ka nie bÄ™dzie pasowaÄ‡. </p> <pre>
            src/components/App.jsx

            import { Routes, Route } from "react-router-dom";
            import Home from "path/to/pages/Home";
            import About from "path/to/pages/About";
            import Products from "path/to/pages/Products";
            import NotFound from "path/to/pages/NotFound";

            const App = () => {
              return (
                &ltdiv>
                  &ltRoutes>
                    &ltRoute path="/" element={&ltHome />} />
                    &ltRoute path="/about" element={&ltAbout />} />
                    &ltRoute path="/products" element={&ltProducts />} />
                    &ltRoute path="*" element={&ltNotFound />} />
                  &lt/Routes>
                &lt/div>
              );
            };
          </pre> <p> Symbol * w propsie path wskazuje na to, Å¼e Å›cieÅ¼ka ta moÅ¼e pokrywaÄ‡ siÄ™ z dowolnÄ… wartoÅ›ciÄ… URL. JeÅ›li Å¼aden wczeÅ›niejszy Route nie bÄ™dzie pasowaÅ‚, ostatni wyÅ›wietli uÅ¼ytkownikowi stronÄ™ z wiadomoÅ›ciÄ…, Å¼e pod danym adresem nie znajduje siÄ™ Å¼adna czÄ™Å›Ä‡ aplikacji. </p> </article> </section> <section id="section4" class="text"> <article id="article1"> <h2>Komponenty Link i NavLink</h2> <p> Teraz przeanalizujemy jak tworzyÄ‡ odnoÅ›niki (linki) do rÃ³Å¼nych stron naszej aplikacji. W celu utworzenia nawigacji w aplikacji Reactowej nie moÅ¼emy korzystaÄ‡ ze zwykÅ‚ego tagu &lta href="/about">. Po klikniÄ™ciu w taki odnoÅ›nik przeglÄ…darka przeÅ‚aduje stronÄ™, zamiast zmieniÄ‡ URL na obecnej stronie i pozwoliÄ‡ routerowi wykonaÄ‡ nawigacjÄ™ u klienta. </p> <p> Do tworzenia odnoÅ›nikÃ³w wykorzystuje siÄ™ komponenty Link i NavLink. RenderujÄ… one tag &lta>, ale standardowe zachowanie odnoÅ›nika jest zmienione tak, aby po klikniÄ™ciu URL aktualizowaÅ‚ siÄ™ bez przeÅ‚adowania strony. </p> <pre>
              &ltnav>
                &ltLink to="/">Home&lt/Link>
                &ltLink to="/about">About&lt/Link>
                &ltLink to="/products">Products&lt/Link>
              &lt/nav>
          </pre> <p> Komponent NavLink rÃ³Å¼ni siÄ™ tylko tym, Å¼e dostaje klasÄ™ .active kiedy bieÅ¼Ä…cy URL pokrywa siÄ™ z wartoÅ›ciÄ… propsa to. MoÅ¼na to wykorzysta do zmiany jego stylÃ³w. </p> <pre>
            src/components/App.jsx

            import { Routes, Route, NavLink } from "react-router-dom";
            import styled from "styled-components";
            import Home from "path/to/pages/Home";
            import About from "path/to/pages/About";
            import Products from "path/to/pages/Products";

            const StyledLink = styled(NavLink)`
              color: black;

              &.active {
                color: orange;
              }
            `;

            export const App = () => {
              return (
                &ltdiv>
                  &ltnav>
                    &ltStyledLink to="/" end>
                      Home
                    &lt/StyledLink>
                    &ltStyledLink to="/about">About&lt/StyledLink>
                    &ltStyledLink to="/products">Products&lt/StyledLink>
                  &lt/nav>

                  &ltRoutes>
                    &ltRoute path="/" element={&ltHome />} />
                    &ltRoute path="/about" element={&ltAbout />} />
                    &ltRoute path="/products" element={&ltProducts />} />
                  &lt/Routes>
                &lt/div>
              );
            };
          </pre> </article> </section> <section id="section5" class="text"> <article id="article1"> <h2>Parametry URL</h2> <p> Dynamiczne parametry URL sÄ… podobne do parametrÃ³w funkcji - zawsze majÄ… jednÄ… nazwÄ™, ale mogÄ… mieÄ‡ rÃ³Å¼ne wartoÅ›ci. PozwalajÄ… zdefiniowaÄ‡ szablon adresu URL, ktÃ³rego czÄ™Å›ci mogÄ… mieÄ‡ dynamicznÄ… wartoÅ›Ä‡. Na przykÅ‚ad, nie ma sensu okreÅ›lanie oddzielnej Å›cieÅ¼ki dla kaÅ¼dego posta na blogu - mogÄ… ich byÄ‡ przecieÅ¼ tysiÄ…ce. JeÅ›li chodzi o strukturÄ™, poszczegÃ³lne strony postÃ³w bÄ™dÄ… identyczne. RÃ³Å¼niÄ‡ siÄ™ bÄ™dzie nazwa, obrazek, autor, tekst itp. Dlatego zamiast okreÅ›laÄ‡ dokÅ‚adnÄ… Å›cieÅ¼kÄ™ dla kaÅ¼dego artykuÅ‚u, moÅ¼emy zadeklarowaÄ‡ jednÄ… - z dynamicznym parametrem. Na jego podstawie bÄ™dziemy okreÅ›laÄ‡, jaki post naleÅ¼y wyÅ›wietliÄ‡ w danym momencie. Dynamiczne parametry URL zapisujemy poprzedajÄ…c nazwÄ™ parametru dwukropkiem (:). </p> <pre>
            &ltRoute path="/blog/:postId" element={&ltBlogPost />} />
          </pre> <p> Za kaÅ¼dym razem, gdy uÅ¼ytkownik bÄ™dzie odwiedzaÄ‡ adres odpowiadajÄ…cy dynamicznej Å›cieÅ¼ki /blog/:postId (np. /blog/react-fundamentals lub /blog/top-5-css-tricks), bÄ™dzie mu siÄ™ wyÅ›wietlaÅ‚a odpowiednia strona postu. </p> <p> MoÅ¼emy nazywaÄ‡ parametry URL dowolnie, jednak warto zadbaÄ‡ o odpowiednie oddanie jego znaczenia. </p> <p> Dodajmy do naszej aplikacji Å›cieÅ¼kÄ™ strony jednego produktu - /products/:productId. Jest to oddzielna strona, w Å¼aden sposÃ³b niezwiÄ…zana z /products - stronÄ… wyÅ›wietlania wszystkich produktÃ³w. </p> <pre>
            src/components/App.jsx

            import { Routes, Route, Link } from "react-router-dom";
            import Home from "path/to/pages/Home";
            import About from "path/to/pages/About";
            import Products from "path/to/pages/Products";
            import NotFound from "path/to/pages/NotFound";
            import ProductDetails from "path/to/pages/ProductDetails";

            export const App = () => {
              return (
                &ltdiv>
                  &ltnav>
                    &ltLink to="/">Home&lt/Link>
                    &ltLink to="/about">About&lt/Link>
                    &ltLink to="/products">Products&lt/Link>
                  &lt/nav>
                  &ltRoutes>
                    &ltRoute path="/" element={&ltHome />} />
                    &ltRoute path="/about" element={&ltAbout />} />
                    &ltRoute path="/products" element={&ltProducts />} />
                    &ltRoute path="/products/:productId" element={&ltProductDetails />} />
                    &ltRoute path="*" element={&ltNotFound />} />
                  &lt/Routes>
                &lt/div>
              );
            };
          </pre> <p> WartoÅ›Ä‡ parametru URL powinna byÄ‡ unikalna wewnÄ…trz kolekcji, dlatego najczÄ™Å›ciej wykorzystywane sÄ… identyfikatory/klucze obiektÃ³w (id), ktÃ³re ustanawia baza danych (liczby lub Å‚aÅ„cuchy). Z tego wzglÄ™du adres najczÄ™Å›ciej ma postaÄ‡ jak /products/1, /proudcts/2 itd. </p> </article> <article id="article2"> <h2>Hook useParams</h2> <p> Zwraca obiekt ze wszystkimi dynamicznymi parametrami, ktÃ³re istniejÄ… w aktualnym adresie URL, ale tylko te ktÃ³re zostaÅ‚y zdefiniowane w ramach Routes. Na przykÅ‚ad, jeÅ›li zadeklarowana zostaÅ‚a nastÄ™pujÄ…ca Å›cieÅ¼ka /books/:genreId/:authorName, i uÅ¼ytkownik znajduje siÄ™ pod adresem /books/adventure/herman-melville, hook zwrÃ³ci obiekt klucz-wartoÅ›Ä‡ postaci: genreId: adventure authorName: herman-melville. </p> <pre>
            const { genreId, authorName } = useParams();
            console.log(genreId, authorName);// adventure, herman-melville
          </pre> <p> W celu otrzymania wartoÅ›ci dynamicznego paramteru URL, dla strony szczegÃ³Å‚Ã³w produktu, wykorzystujemy hook useParams w komponencie strony produktu. </p> <pre>
            src/pages/ProductDetails.jsx

            import { useParams } from "react-router-dom";

            const ProductDetails = () => {
              const { productId } = useParams();
              return &ltdiv>Now showing product with id - {productId}&lt/div>;
            };
          </pre> <p> MajÄ…c wartoÅ›Ä‡ parametru moÅ¼emy wykonaÄ‡ zapytanie do API i otrzymaÄ‡ peÅ‚nÄ… informacjÄ™ o produkcie, zgodnie z jego identyfikatorem, po czym wyrenderowaÄ‡ jego stronÄ™. </p> </article> </section> <section id="section5" class="text"> <article id="article1"> <h2>ZagnieÅ¼dÅ¼one Å›cieÅ¼ki</h2> <p> ZagnieÅ¼dÅ¼one Å›cieÅ¼ki pozwalajÄ… opisywaÄ‡ logikÄ™ "strony w stronie" (sytuacja kiedy dla jednego adresu URL, oprÃ³cz komponentu-rodzica caÅ‚ej strony, bÄ™dzie wyÅ›wietlaÄ‡ siÄ™ jeszcze zagnieÅ¼dÅ¼ony komponent-dziecko). </p> <p> Na przykÅ‚ad, chcielibyÅ›my aby na kaÅ¼dej ze stron /about/mission, /about/team i /about/reviews wyÅ›wietlaÅ‚ siÄ™ komponent &ltAbout /> oraz dodatkowa, bardziej szczegÃ³Å‚owa informacja w zaleÅ¼noÅ›ci od URL (artykuÅ‚ o misji naszej firmy - 'mission', galeria z informacjami o pracownikach - 'team' i recenzje uÅ¼ytkownikÃ³w ' reviews'). </p> <pre>
            // âŒ NieprawidÅ‚owo
            &ltRoute path="/about" element={&ltAbout />} />
            &ltRoute path="/about/mission" element={&ltMission />} />
            &ltRoute path="/about/team" element={&ltTeam />} />
            &ltRoute path="/about/reviews" element={&ltReviews />} />
          </pre> <p> JeÅ¼eli przygotujemy Routing w ten sposÃ³b, to otrzymamy cztery niezaleÅ¼ne strony. Na /about bÄ™dzie wyÅ›wietlaÄ‡ siÄ™ tylko strona z informacjami, a na about/team jedynie galeria pracownikÃ³w. </p> <p> Wykorzystajmy skÅ‚adniÄ™ deklarowania zagnieÅ¼dÅ¼onej Å›cieÅ¼ki, ktÃ³rej komponent bÄ™dzie wyÅ›wietlaÄ‡ siÄ™ wewnÄ…trz strony-rodzica. </p> <pre>
            // âœ… PrawidÅ‚owo
            &ltRoute path="/about" element={&ltAbout />}>
              &ltRoute path="mission" element={&ltMission />} />
              &ltRoute path="team" element={&ltTeam />} />
              &ltRoute path="reviews" element={&ltReviews />} />
            &lt/Route>
          </pre> <p>ZwrÃ³Ä‡ uwagÄ™ na kilka szczegÃ³Å‚Ã³w:</p> <ul class="unnumbered-list-container"> <li> Deklaratywnie umieÅ›ciliÅ›my Å›cieÅ¼ki-dzieci wewnÄ…trz rodzica Route. WÅ‚aÅ›nie taka skÅ‚adnia wskazuje na Å›cieÅ¼kÄ™ zagnieÅ¼dÅ¼onÄ…, ktÃ³rej komponent bÄ™dzie wyÅ›wietlaÅ‚ siÄ™ gdzieÅ› wewnÄ…trz komponentu rodzica. </li> <li> WartoÅ›Ä‡ propsa path w zagnieÅ¼dÅ¼onej Å›cieÅ¼ce definiuje siÄ™ w relacji/odniesieniu do rodzica. WÅ‚aÅ›nie dlatego przekazaliÅ›my wartoÅ›Ä‡ path="mission", a nie peÅ‚nÄ… Å›cieÅ¼kÄ™ path="/about/mission" </li> <li> ÅšcieÅ¼ki relatywne zapisuje siÄ™ bez poprzedzajÄ…cego symbolu /, to znaczy path="mission", a nie path="/mission". JeÅ¼eli dodalibyÅ›my slash, to utworzylibyÅ›my oddzielnÄ… Å›cieÅ¼kÄ™ /mission i zepsulibyÅ›my logikÄ™ Routingu. </li> </ul> <p> PeÅ‚na konfiguracja Routingu naszej aplikacji bÄ™dzie wyglÄ…daÅ‚a tak. </p> <pre>
            src/components/App.jsx

            import { Routes, Route, Link } from "react-router-dom";
            import Home from "path/to/pages/Home";
            import About from "path/to/pages/About";
            import Products from "path/to/pages/Products";
            import NotFound from "path/to/pages/NotFound";
            import ProductDetails from "path/to/pages/ProductDetails";
            import Mission from "path/to/components/Mission";
            import Team from "path/to/components/Team";
            import Reviews from "path/to/components/Reviews";

            export const App = () => {
              return (
                &ltdiv>
                  &ltnav>
                    &ltLink to="/">Home&lt/Link>
                    &ltLink to="/about">About&lt/Link>
                    &ltLink to="/products">Products&lt/Link>
                  &lt/nav>
                  &ltRoutes>
                    &ltRoute path="/" element={&ltHome />} />
                    &ltRoute path="/about" element={&ltAbout />}>
                      &ltRoute path="mission" element={&ltMission />} />
                      &ltRoute path="team" element={&ltTeam />} />
                      &ltRoute path="reviews" element={&ltReviews />} />
                    &lt/Route>
                    &ltRoute path="/products" element={&ltProducts />} />
                    &ltRoute path="/products/:productId" element={&ltProductDetails />} />
                    &ltRoute path="*" element={&ltNotFound />} />
                  &lt/Routes>
                &lt/div>
              );
            };
          </pre> <p> OstatniÄ… kwestiÄ… jest wskazanie, w ktÃ³rym miejscu, w komponencie Route-rodzica About, chcemy renderowaÄ‡ zagnieÅ¼dzone Route-dzieci. W tym celu wykorzystywany jest komponent Outlet. </p> <pre>
            src/pages/About.jsx

            import { Link, Outlet } from "react-router-dom";

            export const About = () => {
              return (
                &ltdiv>
                  &lth1>About page&lt/h1>
                  &ltul>
                    &ltli>
                      &ltLink to="mission">Read about our mission&lt/Link>
                    &lt/li>
                    &ltli>
                      &ltLink to="team">Get to know the team&lt/Link>
                    &lt/li>
                    &ltli>
                      &ltLink to="reviews">Go through the reviews&lt/Link>
                    &lt/li>
                  &lt/ul>
                  &ltOutlet />
                &lt/div>
              );
            };
          </pre> <p> JeÅ›li URL pokryje siÄ™ z wartoÅ›ciÄ… propsa path zagnieÅ¼dÅ¼onej Å›cieÅ¼ki, Outlet wyrenderuje jego komponent. Natomiast dla Å›cieÅ¼ki/about Outlet zwrÃ³ci null, co nie wpÅ‚ynie negatywnie na ukÅ‚ad komponentu-rodzica. </p> <p> ZwrÃ³Ä‡ uwagÄ™ na wartoÅ›Ä‡ propsa to komponentu Link w przykÅ‚adzie powyÅ¼ej. Tak jak path zagnieÅ¼dÅ¼onej Å›cieÅ¼ki, wartoÅ›Ä‡ propsa to zagnieÅ¼dÅ¼onych odnoÅ›nikÃ³w takÅ¼e deklaruje siÄ™ w odniesieniu do adresu URL Route-rodzica. Komponent About renderuje siÄ™ na adresie /about, dlatego odnoÅ›nik z to="mission" bÄ™dzie prowadziÅ‚ do /about/mission. JeÅ¼eli natomiast byÅ‚aby potrzeba utworzenia odnoÅ›nika do innej strony, wtedy konieczne bÄ™dzie wskazanie peÅ‚nej Å›cieÅ¼ki,np. to="/products". </p> </article> </section> <section id="section6" class="text"> <article id="article1"> <h2>ÅšcieÅ¼ki indeksowe</h2> <p> Koncepcja zagnieÅ¼dÅ¼onych Å›cieÅ¼ek pozwala nam rÃ³wnieÅ¼ na tworzenie komponentÃ³w ze wspÃ³lnÄ…, powtarzajÄ…cÄ… siÄ™ na wielu stronach zawartoÅ›ciÄ…. Idealnym przykÅ‚adem jest tutaj menu nawigacji. Z reguÅ‚y powinno siÄ™ ono znajdowaÄ‡ na kaÅ¼dej stronie, aby umoÅ¼liwiÄ‡ swobodnÄ… nawigacjÄ™ po caÅ‚ej aplikacji. Dublowanie kodu i dodawanie komponentu nawigacji do kaÅ¼dego komponentu strony nie jest zbyt praktyczne. Wykorzystajmy wiÄ™c poznanÄ… dotychczas skÅ‚adniÄ™, aby to uproÅ›ciÄ‡. </p> <p> Na poczÄ…tek zdefiniujmy w naszej aplikacji nagÅ‚Ã³wek z logotypem i gÅ‚Ã³wnÄ… nawigacjÄ…, a takÅ¼e kontener ograniczajÄ…cy szerokoÅ›Ä‡ zawartoÅ›ci kaÅ¼dej strony. </p> <pre>
            src/components/App.jsx

            // Imports

            export const App = () => {
              return (
                &ltContainer>
                  &ltHeader>
                    &ltLogo>
                      &ltspan role="img" aria-label="computer icon">
                        ğŸ’»
                      &lt/span>{" "}
                      GoMerch Store
                    &lt/Logo>
                    &ltnav>
                      &ltLink to="/">Home&lt/Link>
                      &ltLink to="/about">About&lt/Link>
                      &ltLink to="/products">Products&lt/Link>
                    &lt/nav>
                  &lt/Header>
                  &ltRoutes>
                    &ltRoute path="/" element={&ltHome />} />
                    &ltRoute path="/about" element={&ltAbout />}>
                      &ltRoute path="mission" element={&ltMission />} />
                      &ltRoute path="team" element={&ltTeam />} />
                      &ltRoute path="reviews" element={&ltReviews />} />
                    &lt/Route>
                    &ltRoute path="/products" element={&ltProducts />} />
                    &ltRoute path="/products/:productId" element={&ltProductDetails />} />
                  &lt/Routes>
                &lt/Container>
              );
            };
          </pre> <p> Teraz przenieÅ›my ten ukÅ‚ad i jego style do oddzielnego komponentu SharedLayout. ZwrÃ³Ä‡ uwagÄ™ na wykorzystanie i poÅ‚oÅ¼enie komponentu Outlet - to w tym miejscu bÄ™dÄ… renderowaÅ‚y siÄ™ komponenty poszczegÃ³lnych stron. </p> <pre>
            src/components/SharedLayout.jsx

            // Imports
            import { Outlet } from "react-router-dom";

            export const SharedLayout = () => {
              return (
                &ltContainer>
                  &ltHeader>
                    &ltLogo>
                      &ltspan role="img" aria-label="computer icon">
                        ğŸ’»
                      &lt/span>{" "}
                      GoMerch Store
                    &lt/Logo>
                    &ltnav>
                      &ltLink to="/">Home&lt/Link>
                      &ltLink to="/about">About&lt/Link>
                      &ltLink to="/products">Products&lt/Link>
                    &lt/nav>
                  &lt/Header>
                  &ltOutlet />
                &lt/Container>
              );
            };
          </pre> <p> Pozostaje wykorzystaÄ‡ nowy komponent w App, tak aby renderowaÅ‚ siÄ™ dla kaÅ¼dej Å›cieÅ¼ki. W tym celu bÄ™dziemy renderowaÄ‡ go na adresie /, a wszystkie pozostaÅ‚e Å›cieÅ¼ki bÄ™dÄ… w nim zagnieÅ¼dÅ¼one. </p> <pre>
            src/components/App.jsx
            
            // Imports
            import { SharedLayout } from "path/to/components/SharedLayout";

            export const App = () => {
              return (
                &ltRoutes>
                  &ltRoute path="/" element={&ltSharedLayout />}>
                    &ltRoute path="about" element={&ltAbout />}>
                      &ltRoute path="mission" element={&ltMission />} />
                      &ltRoute path="team" element={&ltTeam />} />
                      &ltRoute path="reviews" element={&ltReviews />} />
                    &lt/Route>
                    &ltRoute path="products" element={&ltProducts />} />
                    &ltRoute path="products/:productId" element={&ltProductDetails />} />
                  &lt/Route>
                &lt/Routes>
              );
            };
          </pre> <p> ZwrÃ³Ä‡ uwagÄ™ na to, Å¼e zaktualizowane zostaÅ‚y rÃ³wnieÅ¼ Å›cieÅ¼ki dla propsa path - relatywnie do nowego rodzica /. </p> <p> MoÅ¼esz siÄ™ zastanawiaÄ‡ gdzie znikÅ‚ komponent Home, ktÃ³ry wczeÅ›niej renderowaÅ‚ siÄ™ dla path="/"?. PrzecieÅ¼ teraz na / renderuje siÄ™ tylko SharedLayout... Trafne spostrzeÅ¼enie! ChcÄ…c naprawiÄ‡ ten problem musimy dodaÄ‡ tzw. "Å›cieÅ¼kÄ™ indeksowÄ…". </p> <pre>
            src/components/App.jsx
            
            // Imports
            import { SharedLayout } from "path/to/components/SharedLayout";

            export const App = () => {
              return (
                &ltRoutes>
                  &ltRoute path="/" element={&ltSharedLayout />}>
                    &ltRoute index element={&ltHome />} />
                    &ltRoute path="about" element={&ltAbout />}>
                      &ltRoute path="mission" element={&ltMission />} />
                      &ltRoute path="team" element={&ltTeam />} />
                      &ltRoute path="reviews" element={&ltReviews />} />
                    &lt/Route>
                    &ltRoute path="products" element={&ltProducts />} />
                    &ltRoute path="products/:productId" element={&ltProductDetails />} />
                  &lt/Route>
                &lt/Routes>
              );
            };
          </pre> <p> "Indeksowa" moÅ¼e byÄ‡ tylko zagnieÅ¼dÅ¼ona Å›cieÅ¼ka. W jej Route nie wskazuje siÄ™ propsa path, poniewaÅ¼ chcemy aby jej path pokrywaÅ‚ siÄ™ z tym rodzica. Zamiast tego przekazywany jest specjalny props index, ktÃ³ry informuje router, Å¼e Å›cieÅ¼ka indeksowa powinna zostaÄ‡ wyrenderowana pod tym samym adresem, co jego rodzic. </p> <p> MoÅ¼e istnieÄ‡ dowolna iloÅ›Ä‡ Å›cieÅ¼ek indeksowych, wszystko zaleÅ¼y od tego co chcemy osiÄ…gnÄ…Ä‡. Na przykÅ‚ad, jeÅ›li w naszej aplikacji byÅ‚yby strony panelu administratora, dla ktÃ³rych ma obowiÄ…zywaÄ‡ zupeÅ‚nie inny 'layout', to strukturÄ™ Å›cieÅ¼ek moÅ¼na by byÅ‚o zaprojektowaÄ‡ nastÄ™pujÄ…co. </p> <pre>
            &ltRoutes>
              &ltRoute path="/" element={&ltSharedLayout />}>
                &ltRoute index element={&ltHome />} />
                &ltRoute path="about" element={&ltAbout />}>
                  &ltRoute path="mission" element={&ltMission />} />
                  &ltRoute path="team" element={&ltTeam />} />
                  &ltRoute path="reviews" element={&ltReviews />} />
                &lt/Route>
                &ltRoute path="products" element={&ltProducts />} />
                &ltRoute path="products/:productId" element={&ltProductDetails />} />
              &lt/Route>
              &ltRoute path="/admin" element={&ltAdminLayout />}>
                &ltRoute index element={&ltDashboard />} />
                &ltRoute path="sales" element={&ltSales />} />
                &ltRoute path="customers" element={&ltCustomers />} />
              &lt/Route>
            &lt/Routes>
          </pre> </article> </section> </main> <footer class="footer"> <div class="footer-logo"> <img src="/HelpCreatingWebsite/konikMaly24x24Squoosh.989f9831.png" alt="logoImage" width="24"> <img src="/HelpCreatingWebsite/3KLogo.b575da86.png" alt="logoText"> </div> <div id="footer-title"> <p></p> </div> <div class="footer-date"> <p>17.06.2024r.</p> </div> </footer>  <script defer src="/HelpCreatingWebsite/htmlReact/01-wprowadzenieDoReact.ab3a5978.js"></script> </body></html>