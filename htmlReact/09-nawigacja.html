<!DOCTYPE html><html lang="pl"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=Raleway:wght@100;300;700&family=Roboto:wght@300;400&display=swap" rel="stylesheet"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/modern-normalize/1.0.0/modern-normalize.min.css"><link rel="stylesheet" href="/HelpCreatingWebsite/index.c4a3a779.css"><link rel="stylesheet" href="/HelpCreatingWebsite/htmlReact/01-wprowadzenieDoReact.a7417870.css"><title>Nawigacja</title></head><body class="body-container"> <header class="menu-sticky"> <nav class="nav-container">  <ul id="main-menu" class="nav-list-container"></ul> </nav> </header> <main class="main-container">  <section id="section1" class="text"> <article id="article1"> <h1>Moduł 5 - Zajęcia 9 - Nawigacja</h1> <h2>Routing</h2> <p> Elementem wyróżniającym aplikację webową, w porównaniu do desktopowej, jest obecność URL. Zmieniając go, użytkownik może wyświetlać kolejne części aplikacji. Użytkownik może zapisać dany adres w postaci zakładki lub przesłać go do innego użytkownika, który dzięki temu zobaczy ten sam interfejs (z wyjątkiem danych prywatnych). </p> <p>Routing - struktura nawigacji</p> <p>Ścieżka / Route - pojedynczy element nawigacyjny</p> <p> Routing nie jest "miłym dodatkiem" do aplikacji. Przeciwnie, strukturę nawigacji i zestaw podstron należy przemyśleć na samym początku. </p> </article> <article id="article2"> <h3>Struktura łańcucha URL</h3> <p> Analogią łańcucha URL może być adres, pod którym mieszkasz: ulica, dom, mieszkanie. Dla każdego stanu interfejsu (tego co widzi użytkownik) powinien istnieć adres URL. </p> <p> Przeanalizujmy z jakich części może składać się przykładowy URL. </p> <div class="grow_up-img img-container"> <img src="/HelpCreatingWebsite/url-string.2d367099.jpg" alt=""> </div> <ul class="unnumbered-list-container"> <li>https:// - protokół</li> <li>mysite.com/ - host</li> <li> books/e3q76gm9lzk - ścieżka, to gdzie znajdujemy się w aplikacji </li> <li> e3q76gm9lzk - parametr url. Parametry bywają dynamiczne lub statyczne </li> <li>? - symbol początku łańcucha zapytania (search query)</li> <li> ?category=adventure&status=unread - łańcuch zapytania (search query) </li> <li>category=adventure - para parametr=wartość</li> <li>& - symbol "I", rozdziela parametry łańcucha zapytania</li> <li>#comments - kotwica (hash), określa położenie na stronie</li> </ul> </article> <article id="article3"> <h3>Historia nawigacji</h3> <p> Historia nawigacji (przeglądania) zawiera informacje o historii naszego przeglądania danej zakładki przeglądarki. Wykorzystując właściwości i metody HTML5 History API możemy przechodzić do tyłu i do przodu po historii użytkownika i manipulować jego zawartością. </p> <p> Jeśli chcesz lepiej zrozumieć React Router, po zapoznaniu się z podstawowymi koncepcjami rekomendujemy wrócić i przeanalizować artykuł <a href="https://blog.pshrmn.com/a-little-bit-of-history/">A Little Bit of History.</a> </p> </article> <article id="article4"> <h3>Routing w React</h3> <p> W React nie ma wbudowanego modułu routingu, dlatego najczęściej wykorzystuje się <a href="https://reactrouter.com/en/main">React Router</a>. Analogicznie jak React, dostarcza nam zestawu prymitywów do tworzenia interfejsu użytkownika. Zawiera również zestaw hooków do tworzenia routingu, zarządzania historią nawigacji użytkownika i wyświetlania różnych komponentów w zależności od obecnej wartości URL w łańcuchu adresowym przeglądarki. </p> <pre>
            npm install react-router-dom
          </pre> </article> </section> <section id="section2" class="text"> <article id="article1"> <h2>Komponent BrowserRouter</h2> <p> BrowserRouter - centrum sterowania routingiem, które kryje w sobie całą logikę współpracy z historią przeglądarki. Tworzy router i obiekt historii nawigacji, aby synchronizować interfejs z adresem URL. Wykorzystując kontekst React, przekazuje informację o bieżącym stanie historii nawigacji wszystkim potomkom. Na początku wystarczy owinąć komponentem BrowserRouter całą aplikację. </p> <p> Komponent BrowserRouter to Router, który używa interfejsu API historii HTML5 (pushState, replaceState i zdarzenie popstate), aby zapewnić synchronizację interfejsu użytkownika z adresem URL. Dlatego też korzystamy już z rozbudowanego komponentu BrowserRouter. </p> <pre>
            src/index.js
            import { BrowserRouter } from "react-router-dom";

            ReactDOM.createRoot(document.getElementById("root")).render(
              &ltReact.StrictMode>
                &ltBrowserRouter>
                  &ltApp />
                &lt/BrowserRouter>
              &lt/React.StrictMode>
            );
          </pre> <p> W kolejnej części modułu przeanalizujemy jak opisywać routing aplikacji. </p> <p> Komponent BrowserRouter możemy także zapisać używając nowego podejścia, z wykorzystaniem hooków i RouterProvider , natomiast jest to rozwiązanie jeszcze mało popularne. </p> <pre>
            import {
              createBrowserRouter,
              createRoutesFromElements,
              Route,
              RouterProvider,
            } from "react-router-dom";

            const router = createBrowserRouter(
              createRoutesFromElements(
                &ltRoute path="/" element={&ltRoot />}>
                  &ltRoute path="dashboard" element={&ltDashboard />} />
                  {/* ... etc. */}
                &lt/Route>
              )
            );

            ReactDOM.createRoot(document.getElementById("root")).render(
              &ltReact.StrictMode>
                &ltRouterProvider router={router} />
              &lt/React.StrictMode>
            );
          </pre> <p> <a href="https://reactrouter.com/en/main/routers/picking-a-router">Jaki Router wybrać?</a> </p> </article> </section> <section id="section3" class="text"> <article id="article1"> <h2>Komponenty Route i Routes</h2> <p> Komponent Route pozwala powiązać określony URL z konkretnym komponentem. Przykładowo, jeśli chcemy wyświetlić komponent About, kiedy użytkownik przechodzi na ścieżkę /about, należy opisać taką ścieżkę następująco: </p> <pre>
            &ltRoute path="/about" element={&ltAbout />} />
          </pre> <p> Wartością propsu element może być dowolny, poprawny JSX, ale w praktyce wykorzystywane są zawsze komponenty. </p> <p> Komponent Route zawsze musi coś wyrenderować: komponent wskazany w propsie element jeśli path pokrywa się z bieżącą wartością segmentu pathname w polu adresowym przeglądarki lub null, jeśli się nie pokrywa. </p> <p> Możemy zdefinować dowolną ilość ścieżek, ale minimum to jedna na każdą stronę aplikacji. Przypuśćmy, że tworzymy aplikację sklepu z odzieżą: </p> <pre>
            src/components/App.jsx

            import { Routes, Route } from "react-router-dom";
            import Home from "path/to/pages/Home";
            import About from "path/to/pages/About";
            import Products from "path/to/pages/Products";

            export const App = () => {
              return (
                &ltdiv>
                  &ltRoutes>
                    &ltRoute path="/" element={&ltHome />} />
                    &ltRoute path="/about" element={&ltAbout />} />
                    &ltRoute path="/products" element={&ltProducts />} />
                  &lt/Routes>
                &lt/div>
              );
            };
          </pre> <p> Grupę ścieżek musimy owinąć w komponent Routes, nawet jeśli ścieżka jest tylko jedna. Route nigdy nie może być wykorzystywany poza Routes. Komponent Routes odpowiada za logikę wyboru najlepiej pasującego Route dla bieżącej wartości URL w polu adresowym przeglądarki. </p> <p> Wiesz już, że jedną z konwencji struktury plików w aplikacji jest zapisywanie wszystkich komponentów w folderze src/components. Komponent strony to również zwykły komponent React, ale dla wygody i ustrukturyzowania, takie komponenty przechowujemy oddzielnie w folderze src/pages </p> </article> <article id="article1"> <h3>Strona błędu nawigacji</h3> <p> Biorąc pod uwagę dotychczasowy opis routingu sklepu internetowego, kiedy użytkownik przejdzie po odnośniku na adres URL /non-existing-route (lub na dowolny inny, który nie istnieje w naszej aplikacji) - zobaczy pustą zakładkę przeglądarki bez żadnej zwartości. Dzieje się tak, gdyż żaden z opisanych przez nas Route nie pasuje do tego URL. Powinniśmy informować użytkownika o tym, że adres który wybrał nie istnieje (nie został znaleziony). W tym celu na samym końcu listy ścieżek dodamy jeszcze jeden Route, który będzie pokrywał się z dowolnym URL, ale zostanie wybrany tylko wtedy, gdy żadna inna ścieżka nie będzie pasować. </p> <pre>
            src/components/App.jsx

            import { Routes, Route } from "react-router-dom";
            import Home from "path/to/pages/Home";
            import About from "path/to/pages/About";
            import Products from "path/to/pages/Products";
            import NotFound from "path/to/pages/NotFound";

            const App = () => {
              return (
                &ltdiv>
                  &ltRoutes>
                    &ltRoute path="/" element={&ltHome />} />
                    &ltRoute path="/about" element={&ltAbout />} />
                    &ltRoute path="/products" element={&ltProducts />} />
                    &ltRoute path="*" element={&ltNotFound />} />
                  &lt/Routes>
                &lt/div>
              );
            };
          </pre> <p> Symbol * w propsie path wskazuje na to, że ścieżka ta może pokrywać się z dowolną wartością URL. Jeśli żaden wcześniejszy Route nie będzie pasował, ostatni wyświetli użytkownikowi stronę z wiadomością, że pod danym adresem nie znajduje się żadna część aplikacji. </p> </article> </section> <section id="section4" class="text"> <article id="article1"> <h2>Komponenty Link i NavLink</h2> <p> Teraz przeanalizujemy jak tworzyć odnośniki (linki) do różnych stron naszej aplikacji. W celu utworzenia nawigacji w aplikacji Reactowej nie możemy korzystać ze zwykłego tagu &lta href="/about">. Po kliknięciu w taki odnośnik przeglądarka przeładuje stronę, zamiast zmienić URL na obecnej stronie i pozwolić routerowi wykonać nawigację u klienta. </p> <p> Do tworzenia odnośników wykorzystuje się komponenty Link i NavLink. Renderują one tag &lta>, ale standardowe zachowanie odnośnika jest zmienione tak, aby po kliknięciu URL aktualizował się bez przeładowania strony. </p> <pre>
              &ltnav>
                &ltLink to="/">Home&lt/Link>
                &ltLink to="/about">About&lt/Link>
                &ltLink to="/products">Products&lt/Link>
              &lt/nav>
          </pre> <p> Komponent NavLink różni się tylko tym, że dostaje klasę .active kiedy bieżący URL pokrywa się z wartością propsa to. Można to wykorzysta do zmiany jego stylów. </p> <pre>
            src/components/App.jsx

            import { Routes, Route, NavLink } from "react-router-dom";
            import styled from "styled-components";
            import Home from "path/to/pages/Home";
            import About from "path/to/pages/About";
            import Products from "path/to/pages/Products";

            const StyledLink = styled(NavLink)`
              color: black;

              &.active {
                color: orange;
              }
            `;

            export const App = () => {
              return (
                &ltdiv>
                  &ltnav>
                    &ltStyledLink to="/" end>
                      Home
                    &lt/StyledLink>
                    &ltStyledLink to="/about">About&lt/StyledLink>
                    &ltStyledLink to="/products">Products&lt/StyledLink>
                  &lt/nav>

                  &ltRoutes>
                    &ltRoute path="/" element={&ltHome />} />
                    &ltRoute path="/about" element={&ltAbout />} />
                    &ltRoute path="/products" element={&ltProducts />} />
                  &lt/Routes>
                &lt/div>
              );
            };
          </pre> </article> </section> <section id="section5" class="text"> <article id="article1"> <h2>Parametry URL</h2> <p> Dynamiczne parametry URL są podobne do parametrów funkcji - zawsze mają jedną nazwę, ale mogą mieć różne wartości. Pozwalają zdefiniować szablon adresu URL, którego części mogą mieć dynamiczną wartość. Na przykład, nie ma sensu określanie oddzielnej ścieżki dla każdego posta na blogu - mogą ich być przecież tysiące. Jeśli chodzi o strukturę, poszczególne strony postów będą identyczne. Różnić się będzie nazwa, obrazek, autor, tekst itp. Dlatego zamiast określać dokładną ścieżkę dla każdego artykułu, możemy zadeklarować jedną - z dynamicznym parametrem. Na jego podstawie będziemy określać, jaki post należy wyświetlić w danym momencie. Dynamiczne parametry URL zapisujemy poprzedając nazwę parametru dwukropkiem (:). </p> <pre>
            &ltRoute path="/blog/:postId" element={&ltBlogPost />} />
          </pre> <p> Za każdym razem, gdy użytkownik będzie odwiedzać adres odpowiadający dynamicznej ścieżki /blog/:postId (np. /blog/react-fundamentals lub /blog/top-5-css-tricks), będzie mu się wyświetlała odpowiednia strona postu. </p> <p> Możemy nazywać parametry URL dowolnie, jednak warto zadbać o odpowiednie oddanie jego znaczenia. </p> <p> Dodajmy do naszej aplikacji ścieżkę strony jednego produktu - /products/:productId. Jest to oddzielna strona, w żaden sposób niezwiązana z /products - stroną wyświetlania wszystkich produktów. </p> <pre>
            src/components/App.jsx

            import { Routes, Route, Link } from "react-router-dom";
            import Home from "path/to/pages/Home";
            import About from "path/to/pages/About";
            import Products from "path/to/pages/Products";
            import NotFound from "path/to/pages/NotFound";
            import ProductDetails from "path/to/pages/ProductDetails";

            export const App = () => {
              return (
                &ltdiv>
                  &ltnav>
                    &ltLink to="/">Home&lt/Link>
                    &ltLink to="/about">About&lt/Link>
                    &ltLink to="/products">Products&lt/Link>
                  &lt/nav>
                  &ltRoutes>
                    &ltRoute path="/" element={&ltHome />} />
                    &ltRoute path="/about" element={&ltAbout />} />
                    &ltRoute path="/products" element={&ltProducts />} />
                    &ltRoute path="/products/:productId" element={&ltProductDetails />} />
                    &ltRoute path="*" element={&ltNotFound />} />
                  &lt/Routes>
                &lt/div>
              );
            };
          </pre> <p> Wartość parametru URL powinna być unikalna wewnątrz kolekcji, dlatego najczęściej wykorzystywane są identyfikatory/klucze obiektów (id), które ustanawia baza danych (liczby lub łańcuchy). Z tego względu adres najczęściej ma postać jak /products/1, /proudcts/2 itd. </p> </article> <article id="article2"> <h2>Hook useParams</h2> <p> Zwraca obiekt ze wszystkimi dynamicznymi parametrami, które istnieją w aktualnym adresie URL, ale tylko te które zostały zdefiniowane w ramach Routes. Na przykład, jeśli zadeklarowana została następująca ścieżka /books/:genreId/:authorName, i użytkownik znajduje się pod adresem /books/adventure/herman-melville, hook zwróci obiekt klucz-wartość postaci: genreId: adventure authorName: herman-melville. </p> <pre>
            const { genreId, authorName } = useParams();
            console.log(genreId, authorName);// adventure, herman-melville
          </pre> <p> W celu otrzymania wartości dynamicznego paramteru URL, dla strony szczegółów produktu, wykorzystujemy hook useParams w komponencie strony produktu. </p> <pre>
            src/pages/ProductDetails.jsx

            import { useParams } from "react-router-dom";

            const ProductDetails = () => {
              const { productId } = useParams();
              return &ltdiv>Now showing product with id - {productId}&lt/div>;
            };
          </pre> <p> Mając wartość parametru możemy wykonać zapytanie do API i otrzymać pełną informację o produkcie, zgodnie z jego identyfikatorem, po czym wyrenderować jego stronę. </p> </article> </section> <section id="section5" class="text"> <article id="article1"> <h2>Zagnieżdżone ścieżki</h2> <p> Zagnieżdżone ścieżki pozwalają opisywać logikę "strony w stronie" (sytuacja kiedy dla jednego adresu URL, oprócz komponentu-rodzica całej strony, będzie wyświetlać się jeszcze zagnieżdżony komponent-dziecko). </p> <p> Na przykład, chcielibyśmy aby na każdej ze stron /about/mission, /about/team i /about/reviews wyświetlał się komponent &ltAbout /> oraz dodatkowa, bardziej szczegółowa informacja w zależności od URL (artykuł o misji naszej firmy - 'mission', galeria z informacjami o pracownikach - 'team' i recenzje użytkowników ' reviews'). </p> <pre>
            // ❌ Nieprawidłowo
            &ltRoute path="/about" element={&ltAbout />} />
            &ltRoute path="/about/mission" element={&ltMission />} />
            &ltRoute path="/about/team" element={&ltTeam />} />
            &ltRoute path="/about/reviews" element={&ltReviews />} />
          </pre> <p> Jeżeli przygotujemy Routing w ten sposób, to otrzymamy cztery niezależne strony. Na /about będzie wyświetlać się tylko strona z informacjami, a na about/team jedynie galeria pracowników. </p> <p> Wykorzystajmy składnię deklarowania zagnieżdżonej ścieżki, której komponent będzie wyświetlać się wewnątrz strony-rodzica. </p> <pre>
            // ✅ Prawidłowo
            &ltRoute path="/about" element={&ltAbout />}>
              &ltRoute path="mission" element={&ltMission />} />
              &ltRoute path="team" element={&ltTeam />} />
              &ltRoute path="reviews" element={&ltReviews />} />
            &lt/Route>
          </pre> <p>Zwróć uwagę na kilka szczegółów:</p> <ul class="unnumbered-list-container"> <li> Deklaratywnie umieściliśmy ścieżki-dzieci wewnątrz rodzica Route. Właśnie taka składnia wskazuje na ścieżkę zagnieżdżoną, której komponent będzie wyświetlał się gdzieś wewnątrz komponentu rodzica. </li> <li> Wartość propsa path w zagnieżdżonej ścieżce definiuje się w relacji/odniesieniu do rodzica. Właśnie dlatego przekazaliśmy wartość path="mission", a nie pełną ścieżkę path="/about/mission" </li> <li> Ścieżki relatywne zapisuje się bez poprzedzającego symbolu /, to znaczy path="mission", a nie path="/mission". Jeżeli dodalibyśmy slash, to utworzylibyśmy oddzielną ścieżkę /mission i zepsulibyśmy logikę Routingu. </li> </ul> <p> Pełna konfiguracja Routingu naszej aplikacji będzie wyglądała tak. </p> <pre>
            src/components/App.jsx

            import { Routes, Route, Link } from "react-router-dom";
            import Home from "path/to/pages/Home";
            import About from "path/to/pages/About";
            import Products from "path/to/pages/Products";
            import NotFound from "path/to/pages/NotFound";
            import ProductDetails from "path/to/pages/ProductDetails";
            import Mission from "path/to/components/Mission";
            import Team from "path/to/components/Team";
            import Reviews from "path/to/components/Reviews";

            export const App = () => {
              return (
                &ltdiv>
                  &ltnav>
                    &ltLink to="/">Home&lt/Link>
                    &ltLink to="/about">About&lt/Link>
                    &ltLink to="/products">Products&lt/Link>
                  &lt/nav>
                  &ltRoutes>
                    &ltRoute path="/" element={&ltHome />} />
                    &ltRoute path="/about" element={&ltAbout />}>
                      &ltRoute path="mission" element={&ltMission />} />
                      &ltRoute path="team" element={&ltTeam />} />
                      &ltRoute path="reviews" element={&ltReviews />} />
                    &lt/Route>
                    &ltRoute path="/products" element={&ltProducts />} />
                    &ltRoute path="/products/:productId" element={&ltProductDetails />} />
                    &ltRoute path="*" element={&ltNotFound />} />
                  &lt/Routes>
                &lt/div>
              );
            };
          </pre> <p> Ostatnią kwestią jest wskazanie, w którym miejscu, w komponencie Route-rodzica About, chcemy renderować zagnieżdzone Route-dzieci. W tym celu wykorzystywany jest komponent Outlet. </p> <pre>
            src/pages/About.jsx

            import { Link, Outlet } from "react-router-dom";

            export const About = () => {
              return (
                &ltdiv>
                  &lth1>About page&lt/h1>
                  &ltul>
                    &ltli>
                      &ltLink to="mission">Read about our mission&lt/Link>
                    &lt/li>
                    &ltli>
                      &ltLink to="team">Get to know the team&lt/Link>
                    &lt/li>
                    &ltli>
                      &ltLink to="reviews">Go through the reviews&lt/Link>
                    &lt/li>
                  &lt/ul>
                  &ltOutlet />
                &lt/div>
              );
            };
          </pre> <p> Jeśli URL pokryje się z wartością propsa path zagnieżdżonej ścieżki, Outlet wyrenderuje jego komponent. Natomiast dla ścieżki/about Outlet zwróci null, co nie wpłynie negatywnie na układ komponentu-rodzica. </p> <p> Zwróć uwagę na wartość propsa to komponentu Link w przykładzie powyżej. Tak jak path zagnieżdżonej ścieżki, wartość propsa to zagnieżdżonych odnośników także deklaruje się w odniesieniu do adresu URL Route-rodzica. Komponent About renderuje się na adresie /about, dlatego odnośnik z to="mission" będzie prowadził do /about/mission. Jeżeli natomiast byłaby potrzeba utworzenia odnośnika do innej strony, wtedy konieczne będzie wskazanie pełnej ścieżki,np. to="/products". </p> </article> </section> <section id="section6" class="text"> <article id="article1"> <h2>Ścieżki indeksowe</h2> <p> Koncepcja zagnieżdżonych ścieżek pozwala nam również na tworzenie komponentów ze wspólną, powtarzającą się na wielu stronach zawartością. Idealnym przykładem jest tutaj menu nawigacji. Z reguły powinno się ono znajdować na każdej stronie, aby umożliwić swobodną nawigację po całej aplikacji. Dublowanie kodu i dodawanie komponentu nawigacji do każdego komponentu strony nie jest zbyt praktyczne. Wykorzystajmy więc poznaną dotychczas składnię, aby to uprościć. </p> <p> Na początek zdefiniujmy w naszej aplikacji nagłówek z logotypem i główną nawigacją, a także kontener ograniczający szerokość zawartości każdej strony. </p> <pre>
            src/components/App.jsx

            // Imports

            export const App = () => {
              return (
                &ltContainer>
                  &ltHeader>
                    &ltLogo>
                      &ltspan role="img" aria-label="computer icon">
                        💻
                      &lt/span>{" "}
                      GoMerch Store
                    &lt/Logo>
                    &ltnav>
                      &ltLink to="/">Home&lt/Link>
                      &ltLink to="/about">About&lt/Link>
                      &ltLink to="/products">Products&lt/Link>
                    &lt/nav>
                  &lt/Header>
                  &ltRoutes>
                    &ltRoute path="/" element={&ltHome />} />
                    &ltRoute path="/about" element={&ltAbout />}>
                      &ltRoute path="mission" element={&ltMission />} />
                      &ltRoute path="team" element={&ltTeam />} />
                      &ltRoute path="reviews" element={&ltReviews />} />
                    &lt/Route>
                    &ltRoute path="/products" element={&ltProducts />} />
                    &ltRoute path="/products/:productId" element={&ltProductDetails />} />
                  &lt/Routes>
                &lt/Container>
              );
            };
          </pre> <p> Teraz przenieśmy ten układ i jego style do oddzielnego komponentu SharedLayout. Zwróć uwagę na wykorzystanie i położenie komponentu Outlet - to w tym miejscu będą renderowały się komponenty poszczególnych stron. </p> <pre>
            src/components/SharedLayout.jsx

            // Imports
            import { Outlet } from "react-router-dom";

            export const SharedLayout = () => {
              return (
                &ltContainer>
                  &ltHeader>
                    &ltLogo>
                      &ltspan role="img" aria-label="computer icon">
                        💻
                      &lt/span>{" "}
                      GoMerch Store
                    &lt/Logo>
                    &ltnav>
                      &ltLink to="/">Home&lt/Link>
                      &ltLink to="/about">About&lt/Link>
                      &ltLink to="/products">Products&lt/Link>
                    &lt/nav>
                  &lt/Header>
                  &ltOutlet />
                &lt/Container>
              );
            };
          </pre> <p> Pozostaje wykorzystać nowy komponent w App, tak aby renderował się dla każdej ścieżki. W tym celu będziemy renderować go na adresie /, a wszystkie pozostałe ścieżki będą w nim zagnieżdżone. </p> <pre>
            src/components/App.jsx
            
            // Imports
            import { SharedLayout } from "path/to/components/SharedLayout";

            export const App = () => {
              return (
                &ltRoutes>
                  &ltRoute path="/" element={&ltSharedLayout />}>
                    &ltRoute path="about" element={&ltAbout />}>
                      &ltRoute path="mission" element={&ltMission />} />
                      &ltRoute path="team" element={&ltTeam />} />
                      &ltRoute path="reviews" element={&ltReviews />} />
                    &lt/Route>
                    &ltRoute path="products" element={&ltProducts />} />
                    &ltRoute path="products/:productId" element={&ltProductDetails />} />
                  &lt/Route>
                &lt/Routes>
              );
            };
          </pre> <p> Zwróć uwagę na to, że zaktualizowane zostały również ścieżki dla propsa path - relatywnie do nowego rodzica /. </p> <p> Możesz się zastanawiać gdzie znikł komponent Home, który wcześniej renderował się dla path="/"?. Przecież teraz na / renderuje się tylko SharedLayout... Trafne spostrzeżenie! Chcąc naprawić ten problem musimy dodać tzw. "ścieżkę indeksową". </p> <pre>
            src/components/App.jsx
            
            // Imports
            import { SharedLayout } from "path/to/components/SharedLayout";

            export const App = () => {
              return (
                &ltRoutes>
                  &ltRoute path="/" element={&ltSharedLayout />}>
                    &ltRoute index element={&ltHome />} />
                    &ltRoute path="about" element={&ltAbout />}>
                      &ltRoute path="mission" element={&ltMission />} />
                      &ltRoute path="team" element={&ltTeam />} />
                      &ltRoute path="reviews" element={&ltReviews />} />
                    &lt/Route>
                    &ltRoute path="products" element={&ltProducts />} />
                    &ltRoute path="products/:productId" element={&ltProductDetails />} />
                  &lt/Route>
                &lt/Routes>
              );
            };
          </pre> <p> "Indeksowa" może być tylko zagnieżdżona ścieżka. W jej Route nie wskazuje się propsa path, ponieważ chcemy aby jej path pokrywał się z tym rodzica. Zamiast tego przekazywany jest specjalny props index, który informuje router, że ścieżka indeksowa powinna zostać wyrenderowana pod tym samym adresem, co jego rodzic. </p> <p> Może istnieć dowolna ilość ścieżek indeksowych, wszystko zależy od tego co chcemy osiągnąć. Na przykład, jeśli w naszej aplikacji byłyby strony panelu administratora, dla których ma obowiązywać zupełnie inny 'layout', to strukturę ścieżek można by było zaprojektować następująco. </p> <pre>
            &ltRoutes>
              &ltRoute path="/" element={&ltSharedLayout />}>
                &ltRoute index element={&ltHome />} />
                &ltRoute path="about" element={&ltAbout />}>
                  &ltRoute path="mission" element={&ltMission />} />
                  &ltRoute path="team" element={&ltTeam />} />
                  &ltRoute path="reviews" element={&ltReviews />} />
                &lt/Route>
                &ltRoute path="products" element={&ltProducts />} />
                &ltRoute path="products/:productId" element={&ltProductDetails />} />
              &lt/Route>
              &ltRoute path="/admin" element={&ltAdminLayout />}>
                &ltRoute index element={&ltDashboard />} />
                &ltRoute path="sales" element={&ltSales />} />
                &ltRoute path="customers" element={&ltCustomers />} />
              &lt/Route>
            &lt/Routes>
          </pre> </article> </section> </main> <footer class="footer"> <div class="footer-logo"> <img src="/HelpCreatingWebsite/konikMaly24x24Squoosh.989f9831.png" alt="logoImage" width="24"> <img src="/HelpCreatingWebsite/3KLogo.b575da86.png" alt="logoText"> </div> <div id="footer-title"> <p></p> </div> <div class="footer-date"> <p>17.06.2024r.</p> </div> </footer>  <script defer src="/HelpCreatingWebsite/htmlReact/01-wprowadzenieDoReact.ab3a5978.js"></script> </body></html>