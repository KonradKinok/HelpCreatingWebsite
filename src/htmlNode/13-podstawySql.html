<!DOCTYPE html>
<html lang="pl">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Raleway:wght@100;300;700&family=Roboto:wght@300;400&display=swap"
      rel="stylesheet"
    />

    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/modern-normalize/1.0.0/modern-normalize.min.css"
    />
    <!-- <style type="text/css">	@import url(./styles/stylStartowy.css);	</style> -->
    <link rel="stylesheet" href="../styles/stylStartowy.scss" />
    <link rel="stylesheet" href="../styles/nodeStyles/nodeStylest.scss" />
    <title>Podstawy SQL</title>
  </head>
  <body class="body-container">
    <header class="menu-sticky">
      <nav class="nav-container">
        <!-- Nawigacja do innych stron -->
        <ul id="main-menu" class="nav-list-container"></ul>
        <ul id="this-page-menu" class="this-page-menu"></ul>
      </nav>
    </header>
    <main class="main-container">
      <!-- section1 -->
      <section id="1" class="text">
        <h1>Moduł 7 - Zajęcia 12 - Materiały dodatkowe - Podstawy SQL</h1>
        <article id="1.1">
          <h2>1.1 Praca z bazami SQL</h2>
        </article>
        <article id="1.2">
          <h3>1.2 CREATE TABLE: Tworzymy tabelę</h3>
          <p>
            Do utworzenia tabeli w SQL wykorzystywane jest wyrażenie CREATE TABLE. Przyjmuje ono
            jako parametry nazwy kolumn, które chcemy wprowadzić, a także ich typy danych.
          </p>
          <p>Utworzymy trzy tabele z nazwami "genders", "users" i "contacts".</p>
          <p>W tabeli "genders" będą trzy kolumny:</p>
          <ul class="unnumbered-list-container">
            <li>id - numer porządkowy płci typ INT, to unikalny klucz;</li>
            <li>name - nazwa płci typ VARCHAR(30);</li>
            <li>
              created_at - czas utworzenia zapisu typ TIMESTAMP, wartość domyśla to obecny czas i
              data.
            </li>
          </ul>
          <p>Kod do utworzenia:</p>
          <pre>
            CREATE TABLE genders (
                id INT PRIMARY KEY,
                name VARCHAR(30),
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );
          </pre>
          <p>W tabeli "users" będziemy mieli siedem kolumn:</p>
          <ul class="unnumbered-list-container">
            <li>id - numer porządkowy kontaktu typ INT, to unikalny klucz;</li>
            <li>name - nazwa użytkownika, typ VARCHAR(30)</li>
            <li>email - adres elektroniczny użytkownika, typ VARCHAR(30);</li>
            <li>password - hasło użytkownika, typ VARCHAR(30);</li>
            <li>age - wiek użytkownika, typ TINYINT UNSIGNED;</li>
            <li>
              gender_id - to foreign key, który wiąże tabele "users" i "genders" połączeniem jeden
              do wielu. Jedna płeć może być u wielu użytkowników;
            </li>
            <li>
              created_at - czas utworzenia zapisu typ TIMESTAMP, wartość domyślna to bieżące czas i
              data.
            </li>
          </ul>
          <p>Kod do utworzenia:</p>
          <pre>
            CREATE TABLE users (
                id INT PRIMARY KEY,
                name VARCHAR(30),
                email VARCHAR(30),
                password VARCHAR(30),
                age TINYINT UNSIGNED,
                gender_id INT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (gender_id) REFERENCES genders (id)
                      ON DELETE SET NULL
                      ON UPDATE CASCADE
            );
          </pre>
          <p>Tutaj pojawiła się u nas instrukcja:</p>
          <pre>
                FOREIGN KEY (gender_id) REFERENCES genders (id)
                      ON DELETE SET NULL
                      ON UPDATE CASCADE
          </pre>
          <p>
            Mówi, że dla kolumny gender_id w tabeli users należy utworzyć referencyjny odnośnik do
            tabeli genders, przy czym wartość kolumny będzie się zgadzać z wartością kolumny id w
            tabeli genders dla konkretnego zapisu. Zapis ON DELETE SET NULL mówi, że jeśli zapis
            będzie usunięty z tabeli genders, wtedy powinniśmy wartość dla kolumny gender w tabeli
            users ustawić w wartości NULL. Zapis ON UPDATE CASCADE mówi, że jeśli zmieniona zostanie
            wartość pola id w tabeli genders, to wartość dla kolumny gender_id w tabeli users
            również zostanie automatycznie zmieniona.
          </p>
          <p>W tabeli "contacts" będzie siedem kolumn:</p>
          <ul class="unnumbered-list-container">
            <li>id - numer porządkowy kontaktu typ INT, to unikalny klucz;</li>
            <li>name - nazwa kontaktu typ VARCHAR(30);</li>
            <li>email - adres elektroniczny kontaktu typ VARCHAR(30);</li>
            <li>phone - telefon kontaktu typ VARCHAR(30);</li>
            <li>favorite - kontakt znajduje się w ulubionych lub nie, logicznego typu;</li>
            <li>
              user_id - to foreign key, który wiąże tablicę "contacts" i "users" połączeniem jeden
              do wielu. Jeden użytkownik może mieć wiele kontaktów;
            </li>
            <li>
              created_at - czas utworzenia zapisu typ TIMESTAMP, wartość domyślna to bieżące czas i
              data.
            </li>
          </ul>
          <p>Kod będzie wyglądał następująco:</p>
          <pre>
            CREATE TABLE contacts (
                id INT PRIMARY KEY,
                name VARCHAR(30),
                email VARCHAR(30),
                phone VARCHAR(30),
                favorite BOOLEAN,
                user_id INT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users (id)
                      ON DELETE CASCADE
                      ON UPDATE CASCADE
            );
          </pre>
          <p>Po tym nasza baza danych będzie miała następujący ER-wykres:</p>
          <div class="img-container grow_up-img">
            <img src="../images/node/61-baza-sql-1.png" alt="" />
          </div>
        </article>
        <article id="1.3">
          <h3>1.3 INSERT: Wprowadzanie danych</h3>
          <p>
            Teraz uzupełnijmy nasze tabele. Można to zrobić przy pomocy polecenia INSERT. Format
            polecenia przed wprowadzeniem danych - pokazujemy nazwę kolumn. Jeżeli nie wskażemy
            którejś z kolumn, na jej miejscu będzie zapisane NULL lub wartość domyślna.
          </p>
          <p>Wstawmy wartości do tabeli genders:</p>
          <pre>
            INSERT INTO genders (id, name)
            VALUES (1, 'male'), (2, 'female');
          </pre>
          <p>
            Przy wstawianiu nie wskazaliśmy wartości dla pola created_at, ale dzięki instrukcji
            DEFAULT CURRENT_TIMESTAMP wartość będzie podstawiona automatycznie.
          </p>
          <p>Wstawiamy wartość do tabeli users:</p>
          <pre>
            INSERT INTO users (id, name, email, password, age, gender_id)
            VALUES (1, 'Boris', 'boris@test.com', 'password', 23, 1),
            (2, 'Alina', 'alina@test.com', 'password', 32, 2),
            (3, 'Maksim', 'maksim@test.com', 'password', 40, 1);
          </pre>
          <p>Wstawiamy wartość do tabeli contacts:</p>
          <pre>
            INSERT INTO contacts (id, name, email, phone, favorite, user_id)
            VALUES (1, 'Allen Raymond', 'nulla.ante@vestibul.co.uk', '(992) 914-3792', 0, 1),
            (2, 'Chaim Lewis', 'dui.in@egetlacus.ca', '(294) 840-6685', 1, 1),
            (3, 'Kennedy Lane', 'mattis.Cras@nonenimMauris.net', '(542) 451-7038', 1, 2),
            (4, 'Wylie Pope', 'est@utquamvel.net', '(692) 802-2949', 0, 2),
            (5, 'Cyrus Jackson', 'nibh@semsempererat.com', '(501) 472-5218', 0, null);
          </pre>
        </article>
        <article id="1.4">
          <h3>1.4 SELECT: Odebranie danych</h3>
          <p>
            Dane zapytanie wykorzystywane jest w przypadku, w którym musimy pokazać dane w tabeli.
            Chyba najprostszym przykładem wykorzystywania SELECT będzie następujące zapytanie:
          </p>
          <pre>
            SELECT * FROM contacts
          </pre>
          <p>Rezultatem danego zapytania będzie tabela ze wszystkimi danymi w tabeli contacts.</p>
          <table class="table-metody-odpowiedzi">
            <thead>
              <tr>
                <th>id</th>
                <th>name</th>
                <th>email</th>
                <th>phone</th>
                <th>favorite</th>
                <th>user</th>
                <th>created_at</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>1</td>
                <td>Allen Raymond</td>
                <td>
                  <a
                    href="mailto:nulla.ante@vestibul.co.uk"
                    target="_blank"
                    rel="noopener noreferrer"
                    >nulla.ante@vestibul.co.uk</a
                  >
                </td>
                <td>(992) 914-3792</td>
                <td>0</td>
                <td>1</td>
                <td>2021-06-06 23:18:08</td>
              </tr>
              <tr>
                <td>2</td>
                <td>Chaim Lewis</td>
                <td>
                  <a href="mailto:dui.in@egetlacus.ca" target="_blank" rel="noopener noreferrer"
                    >dui.in@egetlacus.ca</a
                  >
                </td>
                <td>(294) 840-6685</td>
                <td>1</td>
                <td>1</td>
                <td>2021-06-06 23:18:08</td>
              </tr>
              <tr>
                <td>3</td>
                <td>Kennedy Lane</td>
                <td>
                  <a
                    href="mailto:mattis.Cras@nonenimMauris.net"
                    target="_blank"
                    rel="noopener noreferrer"
                    >mattis.Cras@nonenimMauris.net</a
                  >
                </td>
                <td>(542) 451-7038</td>
                <td>1</td>
                <td>2</td>
                <td>2021-06-06 23:18:08</td>
              </tr>
              <tr>
                <td>4</td>
                <td>Wylie Pope</td>
                <td>
                  <a href="mailto:est@utquamvel.net" target="_blank" rel="noopener noreferrer"
                    >est@utquamvel.net</a
                  >
                </td>
                <td>(692) 802-2949</td>
                <td>0</td>
                <td>2</td>
                <td>2021-06-06 23:18:08</td>
              </tr>
              <tr>
                <td>5</td>
                <td>Cyrus Jackson</td>
                <td>
                  <a href="mailto:nibh@semsempererat.com" target="_blank" rel="noopener noreferrer"
                    >nibh@semsempererat.com</a
                  >
                </td>
                <td>(501) 472-5218</td>
                <td>0</td>
                <td></td>
                <td>2021-06-06 23:18:08</td>
              </tr>
            </tbody>
          </table>
          <p>
            Znak gwiazdki * oznacza, że chcemy pokazać wszystkie kolumny z tabeli bez wyjątków.
            Ponieważ w bazie danych zazwyczaj jest więcej niż jedna tabela, musimy wskazać nazwę
            tej, z której dane chcemy zobaczyć. Robi się to, wykorzystując słowo kluczowe FROM.
          </p>
          <p>
            Gdy potrzebujesz tylko niektórych kolumn z tabeli, możesz wskazać ich nazwy przez
            przecinek zamiast gwiazdki.
          </p>
          <pre>
            SELECT name, email FROM contacts ORDER BY name
          </pre>
          <p>
            Czasem potrzebujemy posortować wyjściowe dane. W tym celu wykorzystujemy ORDER BY "nazwa
            kolumny". OREDER BY ma dwa modyfikatory: ASC sortować rosnąco, wartość domyślna i DESC
            sortować malejąco:
          </p>
          <table class="table-metody-odpowiedzi">
            <thead>
              <tr>
                <th>name</th>
                <th>email</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Allen Raymond</td>
                <td>
                  <a
                    href="mailto:nulla.ante@vestibul.co.uk"
                    target="_blank"
                    rel="noopener noreferrer"
                    >nulla.ante@vestibul.co.uk</a
                  >
                </td>
              </tr>
              <tr>
                <td>Chaim Lewis</td>
                <td>
                  <a href="mailto:dui.in@egetlacus.ca" target="_blank" rel="noopener noreferrer"
                    >dui.in@egetlacus.ca</a
                  >
                </td>
              </tr>
              <tr>
                <td>Cyrus Jackson</td>
                <td>
                  <a href="mailto:nibh@semsempererat.com" target="_blank" rel="noopener noreferrer"
                    >nibh@semsempererat.com</a
                  >
                </td>
              </tr>
              <tr>
                <td>Kennedy Lane</td>
                <td>
                  <a
                    href="mailto:mattis.Cras@nonenimMauris.net"
                    target="_blank"
                    rel="noopener noreferrer"
                    >mattis.Cras@nonenimMauris.net</a
                  >
                </td>
              </tr>
              <tr>
                <td>Wylie Pope</td>
                <td>
                  <a href="mailto:est@utquamvel.net" target="_blank" rel="noopener noreferrer"
                    >est@utquamvel.net</a
                  >
                </td>
              </tr>
            </tbody>
          </table>
          <p>
            Aby włączyć do danych wyjściowych tylko niektóre konkretne zapisy według warunku,
            wykorzystuje się słowo kluczowe WHERE. Pozwala ono filtrować dane po określonym warunku.
          </p>
          <p>W następnym zapytaniu wprowadzimy tylko wybrane kontakty.</p>
          <pre>
            SELECT name, email
            FROM contacts
            WHERE favorite = true
            ORDER BY name
          </pre>
          <p>Wynik:</p>
          <table class="table-metody-odpowiedzi">
            <thead>
              <tr>
                <th>name</th>
                <th>email</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Chaim Lewis</td>
                <td>
                  <a href="mailto:dui.in@egetlacus.ca" target="_blank" rel="noopener noreferrer"
                    >dui.in@egetlacus.ca</a
                  >
                </td>
              </tr>
              <tr>
                <td>Kennedy Lane</td>
                <td>
                  <a
                    href="mailto:mattis.Cras@nonenimMauris.net"
                    target="_blank"
                    rel="noopener noreferrer"
                    >mattis.Cras@nonenimMauris.net</a
                  >
                </td>
              </tr>
            </tbody>
          </table>
          <p>
            Warunki w WHERE mogą być napisane z wykorzystaniem logicznych operatorów AND i OR, a
            także matematycznych operatorów porównania (=, &lt, >, &lt=, >=, &lt>).
          </p>
          <p>
            Warunki w WHERE mogą być zapisane z wykorzystaniem jeszcze kilku poleceń, które
            wyglądają następująco:
          </p>
          <h4>
            IN - IN - porównuje wartość w kolumnie z kilkoma możliwymi wartościami i zwraca true,
            jeżeli wartość pokrywa się choćby z jedną wartością.
          </h4>
          <pre>
            SELECT name, email
            FROM users
            WHERE age IN(20, 30, 40)
            ORDER BY name
          </pre>
          <p>Wynik:</p>
          <table class="table-metody-odpowiedzi">
            <thead>
              <tr>
                <th>name</th>
                <th>email</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Maksim</td>
                <td>
                  <a href="mailto:maksim@test.com" target="_blank" rel="noopener noreferrer"
                    >maksim@test.com</a
                  >
                </td>
              </tr>
            </tbody>
          </table>
          <h4>BETWEEN - sprawdza, czy wartość znajduje się w jakimś przedziale.</h4>
          <pre>
            SELECT name, email, age
            FROM users
            WHERE age BETWEEN 30 AND 40
            ORDER BY name
          </pre>
          <p>Wynik:</p>
          <table class="table-metody-odpowiedzi">
            <thead>
              <tr>
                <th>name</th>
                <th>email</th>
                <th>age</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Alina</td>
                <td>
                  <a href="mailto:alina@test.com" target="_blank" rel="noopener noreferrer"
                    >alina@test.com</a
                  >
                </td>
                <td>32</td>
              </tr>
              <tr>
                <td>Maksim</td>
                <td>
                  <a href="mailto:maksim@test.com" target="_blank" rel="noopener noreferrer"
                    >maksim@test.com</a
                  >
                </td>
                <td>40</td>
              </tr>
            </tbody>
          </table>
          <h4>LIKE - wyszukuje po szablonie.</h4>
          <p>
            Tak więc, jeżeli chcemy wyprowadzić wszystkie kontakty, w których nazwie jest litera
            'L', możemy wykorzystać następujący zapis:
          </p>
          <pre>
            SELECT name, email
            FROM contacts
            WHERE name LIKE '%L%'
            ORDER BY name
          </pre>
          <p>Znak % oznacza dowolny ciąg znaków (0 znaków również się do tego zalicza).</p>
          <p>Wynik:</p>
          <table class="table-metody-odpowiedzi">
            <thead>
              <tr>
                <th>name</th>
                <th>email</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Allen Raymond</td>
                <td>
                  <a
                    href="mailto:nulla.ante@vestibul.co.uk"
                    target="_blank"
                    rel="noopener noreferrer"
                    >nulla.ante@vestibul.co.uk</a
                  >
                </td>
              </tr>
              <tr>
                <td>Chaim Lewis</td>
                <td>
                  <a href="mailto:dui.in@egetlacus.ca" target="_blank" rel="noopener noreferrer"
                    >dui.in@egetlacus.ca</a
                  >
                </td>
              </tr>
              <tr>
                <td>Kennedy Lane</td>
                <td>
                  <a
                    href="mailto:mattis.Cras@nonenimMauris.net"
                    target="_blank"
                    rel="noopener noreferrer"
                    >mattis.Cras@nonenimMauris.net</a
                  >
                </td>
              </tr>
              <tr>
                <td>Wylie Pope</td>
                <td>
                  <a href="mailto:est@utquamvel.net" target="_blank" rel="noopener noreferrer"
                    >est@utquamvel.net</a
                  >
                </td>
              </tr>
            </tbody>
          </table>
          <p>
            W SQL również jest inwersja. W tym celu trzeba napisać NOT przed dowolnym logicznym
            wyrażeniem w warunku (NOT BETWEEN i tak dalej).
          </p>
          <pre>
            SELECT name, email, age
            FROM users
            WHERE age NOT BETWEEN 30 AND 40
            ORDER BY name
          </pre>
          <p>Wynik:</p>
          <table class="table-metody-odpowiedzi">
            <thead>
              <tr>
                <th>name</th>
                <th>email</th>
                <th>age</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Boris</td>
                <td>
                  <a href="mailto:boris@test.com" target="_blank" rel="noopener noreferrer"
                    >boris@test.com</a
                  >
                </td>
                <td>23</td>
              </tr>
            </tbody>
          </table>
        </article>
        <article id="1.5">
          <h3>1.5 Funkcje agregacji</h3>
          <p>
            SQL ma wiele wbudowanych funkcji do wykonywania różnych operacji. Przeanalizujemy
            najczęściej wykorzystywane:
          </p>
          <ul class="unnumbered-list-container">
            <li>COUNT() - zwraca ilość linijek;</li>
            <li>SUM() - zwraca sumę wszystkich pól z liczbowymi wartościami w nich;</li>
            <li>AVG() - zwraca średnią wartość wśród linijek;</li>
            <li>MIN()/MAX() - zwraca minimalną/maksymalną wartość wśród linijek.</li>
          </ul>
          <p>Znajdź minimalny wiek wśród użytkowników.</p>
          <pre>
            SELECT min(age) as minAge
            FROM users
          </pre>
          <p>Wynik:</p>
          <table class="table-metody-odpowiedzi">
            <thead>
              <tr>
                <th>minAge</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>23</td>
              </tr>
            </tbody>
          </table>
          <p>Znajdź średni wiek użytkowników:</p>
          <pre>
            SELECT avg(age) as averageAge
            FROM users
          </pre>
          <p>Wynik:</p>
          <table class="table-metody-odpowiedzi">
            <thead>
              <tr>
                <th>averageAge</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>31.666666666666668</td>
              </tr>
            </tbody>
          </table>
          <p>
            Znajdźmy ilość kontaktów dla każdego użytkownika przy pomocy funkcji COUNT. W operatorze
            SELECT musimy dodać łańcuch GROUP BY user_id, ponieważ funkcja jest agregowana po polu
            user_id i należy grupować znaczenia po nazwie.
          </p>
          <pre>
            SELECT COUNT(user_id) as total_contacts, user_id
            FROM contacts
            GROUP BY user_id
          </pre>
          <p>Wynik:</p>
          <table class="table-metody-odpowiedzi">
            <thead>
              <tr>
                <th>total_contacts</th>
                <th>user_id</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>0</td>
                <td></td>
              </tr>
              <tr>
                <td>2</td>
                <td>1</td>
              </tr>
              <tr>
                <td>2</td>
                <td>2</td>
              </tr>
            </tbody>
          </table>
          <p>
            Tak jak oczekiwaliśmy, dla każdego użytkownika dodaliśmy po dwa kontakty. Jest także
            kontakt bez użytkownika.
          </p>
        </article>
        <article id="1.6">
          <h3>1.6 Umieszczone SELECT</h3>
          <p>
            Dotychczas analizowaliśmy tylko proste zapytania. Często jednak trzeba wykorzystać tak
            zwane umieszczone zapytania lub podzapytania.
          </p>
          <p>
            Należy wyprowadzić kontakty dla użytkowników, których wiek jest mniejszy niż 30 lat.
          </p>
          <p>Pierwsze zapytanie, znaleźć id użytkowników młodszych niż 30 lat.</p>
          <pre>
            SELECT id
            FROM users
            WHERE age < 30
          </pre>
          <p>Następnie łączymy zapytania przy pomocy WHERE:</p>
          <pre>
            SELECT *
            FROM contacts
            WHERE user_id IN (SELECT id
                FROM users
                WHERE age < 30)
          </pre>
          <p>Wynik:</p>
          <table class="table-metody-odpowiedzi">
            <thead>
              <tr>
                <th>id</th>
                <th>name</th>
                <th>email</th>
                <th>phone</th>
                <th>favorite</th>
                <th>user_id</th>
                <th>created_at</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>1</td>
                <td>Allen Raymond</td>
                <td>
                  <a
                    href="mailto:nulla.ante@vestibul.co.uk"
                    target="_blank"
                    rel="noopener noreferrer"
                    >nulla.ante@vestibul.co.uk</a
                  >
                </td>
                <td>(992) 914-3792</td>
                <td>0</td>
                <td>1</td>
                <td>2021-06-07 07:59:35</td>
              </tr>
              <tr>
                <td>2</td>
                <td>Chaim Lewis</td>
                <td>
                  <a href="mailto:dui.in@egetlacus.ca" target="_blank" rel="noopener noreferrer"
                    >dui.in@egetlacus.ca</a
                  >
                </td>
                <td>(294) 840-6685</td>
                <td>1</td>
                <td>1</td>
                <td>2021-06-07 07:59:35</td>
              </tr>
            </tbody>
          </table>
        </article>
        <article id="1.7">
          <h3>1.7 Pseudonimy</h3>
          <p>
            W poprzednich przykładach używaliśmy już pseudonimów. Aby nadać kolumnie pseudonim,
            można wykorzystać słowo klucz AS:
          </p>
          <pre>
            SELECT id, name as fullName, phone as mobile
            FROM contacts
          </pre>
          <p>Wynik:</p>
          <table class="table-metody-odpowiedzi">
            <thead>
              <tr>
                <th>id</th>
                <th>fullName</th>
                <th>mobile</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>1</td>
                <td>Allen Raymond</td>
                <td>(992) 914-3792</td>
              </tr>
              <tr>
                <td>2</td>
                <td>Chaim Lewis</td>
                <td>(294) 840-6685</td>
              </tr>
              <tr>
                <td>3</td>
                <td>Kennedy Lane</td>
                <td>(542) 451-7038</td>
              </tr>
              <tr>
                <td>4</td>
                <td>Wylie Pope</td>
                <td>(692) 802-2949</td>
              </tr>
              <tr>
                <td>5</td>
                <td>Cyrus Jackson</td>
                <td>(501) 472-5218</td>
              </tr>
            </tbody>
          </table>
          <p>Pseudonimy często wykorzystuje się na początku pracy z powiązanymi tabelami.</p>
        </article>
        <article id="1.8">
          <h3>1.8 JOIN: Przyłączenie tabeli</h3>
          <p>
            W bazach danych tabele są najczęściej powiązane między sobą. Na przykład, mamy tabele
            users i genders powiązane ze sobą polem gender_id, a tabele contacts i users polem
            user_id.
          </p>
          <p>
            Do połączenia tabel wykorzystuje się opertator JOIN. Przeanalizujemy konkretne
            przykłady.
          </p>
          <p>
            Jak już wspomnieliśmy, w tabeli users znajduje się kolumna gender_id, w danym przypadku
            jest ona tak zwanym foreign key i ogniwem łączącym dwie tabele. Jeżeli chcemy
            wyprowadzić wszystkie informacje o użytkowniku, łącznie z informacją o jego płci, musimy
            podłączyć drugą tabelę genders. Aby to zrobić, można wykorzystać INNER JOIN, gdzie
            warunek połączenia wprowadza się przy pomocy ON:
          </p>
          <pre>
            SELECT u.id, u.name, u.email, g.name AS gender
            FROM users AS u
            INNER JOIN genders AS g ON g.id = u.gender_id
          </pre>
          <p>Wynik:</p>
          <table class="table-metody-odpowiedzi">
            <thead>
              <tr>
                <th>id</th>
                <th>name</th>
                <th>email</th>
                <th>gender</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>1</td>
                <td>Boris</td>
                <td>
                  <a href="mailto:boris@test.com" target="_blank" rel="noopener noreferrer"
                    >boris@test.com</a
                  >
                </td>
                <td>male</td>
              </tr>
              <tr>
                <td>2</td>
                <td>Alina</td>
                <td>
                  <a href="mailto:alina@test.com" target="_blank" rel="noopener noreferrer"
                    >alina@test.com</a
                  >
                </td>
                <td>female</td>
              </tr>
              <tr>
                <td>3</td>
                <td>Maksim</td>
                <td>
                  <a href="mailto:maksim@test.com" target="_blank" rel="noopener noreferrer"
                    >maksim@test.com</a
                  >
                </td>
                <td>male</td>
              </tr>
            </tbody>
          </table>
          <p>
            To prosty przykład wykorzystania JOIN. Istnieje jeszcze kilka wariantów jego
            wykorzystania:
          </p>
          <ul class="unnumbered-list-container">
            <li>(INNER) JOIN: Zwraca zapisy, których wartości odpowiadają sobie w obu tabelach.</li>
            <li>
              LEFT (OUTER) JOIN: Zwraca wszystkie zapisy z lewej tabeli i odpowiadające zapisy z
              prawej tabeli.
            </li>
            <li>
              RIGHT (OUTER) JOIN: Zwraca wszystkie zapisy z prawej tabeli i odpowiadające zapisy z
              lewej tabeli.
            </li>
            <li>
              FULL (OUTER) JOIN: Zwraca wszystkie zapisy, jeżeli są zgodności w lewej lub prawej
              tabeli.
            </li>
          </ul>
          <div class="img-container grow_up-img">
            <img src="../images/node/62-baza-sql-2.png" alt="" />
          </div>
          <p>
            W okrągłym nawiasie słowa można domyślnie nie pisać, to znaczy zapisy INNER JOINiJOIN`
            to ekwiwalenty.
          </p>
          <p>
            Przeanalizujmy konkretny przykład, aby zrozumieć różnicę między INNER JOIN i LEFT JOIN:
          </p>
          <pre>
            SELECT c.id, c.name, c.email, u.name AS owner
            FROM contacts AS c
            JOIN users AS u ON u.id = c.user_id
          </pre>
          <p>Wynik:</p>
          <table class="table-metody-odpowiedzi">
            <thead>
              <tr>
                <th>id</th>
                <th>name</th>
                <th>email</th>
                <th>owner</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>1</td>
                <td>Allen Raymond</td>
                <td>
                  <a
                    href="mailto:nulla.ante@vestibul.co.uk"
                    target="_blank"
                    rel="noopener noreferrer"
                    >nulla.ante@vestibul.co.uk</a
                  >
                </td>
                <td>Boris</td>
              </tr>
              <tr>
                <td>2</td>
                <td>Chaim Lewis</td>
                <td>
                  <a href="mailto:dui.in@egetlacus.ca" target="_blank" rel="noopener noreferrer"
                    >dui.in@egetlacus.ca</a
                  >
                </td>
                <td>Boris</td>
              </tr>
              <tr>
                <td>3</td>
                <td>Kennedy Lane</td>
                <td>
                  <a
                    href="mailto:mattis.Cras@nonenimMauris.net"
                    target="_blank"
                    rel="noopener noreferrer"
                    >mattis.Cras@nonenimMauris.net</a
                  >
                </td>
                <td>Alina</td>
              </tr>
              <tr>
                <td>4</td>
                <td>Wylie Pope</td>
                <td>
                  <a href="mailto:est@utquamvel.net" target="_blank" rel="noopener noreferrer"
                    >est@utquamvel.net</a
                  >
                </td>
                <td>Alina</td>
              </tr>
            </tbody>
          </table>
          <p>
            W tym przypadku, w próbie, nie otrzymujemy kontaktu bez użytkownika, ponieważ
            wykorzystywane było skrzyżowanie tabel. Aby otrzymać wszystkie kontakty, nawet jeśli
            brak przy nich właścicieli z tabeli users, musimy wykorzystać LEFT JOIN.
          </p>
          <pre>
            SELECT c.id, c.name, c.email, u.name AS owner
            FROM contacts AS c
            LEFT JOIN users AS u ON u.id = c.user_id
          </pre>
          <p>Wynik:</p>
          <table class="table-metody-odpowiedzi">
            <thead>
              <tr>
                <th>id</th>
                <th>name</th>
                <th>email</th>
                <th>owner</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>1</td>
                <td>Allen Raymond</td>
                <td>
                  <a
                    href="mailto:nulla.ante@vestibul.co.uk"
                    target="_blank"
                    rel="noopener noreferrer"
                    >nulla.ante@vestibul.co.uk</a
                  >
                </td>
                <td>Boris</td>
              </tr>
              <tr>
                <td>2</td>
                <td>Chaim Lewis</td>
                <td>
                  <a href="mailto:dui.in@egetlacus.ca" target="_blank" rel="noopener noreferrer"
                    >dui.in@egetlacus.ca</a
                  >
                </td>
                <td>Boris</td>
              </tr>
              <tr>
                <td>3</td>
                <td>Kennedy Lane</td>
                <td>
                  <a
                    href="mailto:mattis.Cras@nonenimMauris.net"
                    target="_blank"
                    rel="noopener noreferrer"
                    >mattis.Cras@nonenimMauris.net</a
                  >
                </td>
                <td>Alina</td>
              </tr>
              <tr>
                <td>4</td>
                <td>Wylie Pope</td>
                <td>
                  <a href="mailto:est@utquamvel.net" target="_blank" rel="noopener noreferrer"
                    >est@utquamvel.net</a
                  >
                </td>
                <td>Alina</td>
              </tr>
              <tr>
                <td>5</td>
                <td>Cyrus Jackson</td>
                <td>
                  <a href="mailto:nibh@semsempererat.com" target="_blank" rel="noopener noreferrer"
                    >nibh@semsempererat.com</a
                  >
                </td>
                <td>NULL</td>
              </tr>
            </tbody>
          </table>
        </article>
        <article id="1.9">
          <h3>1.9 UPDATE: Zmiana danych</h3>
          <p>Zmiana danych w tabeli SQL, robi się to przy pomocy polecenia UPDATE.</p>
          <p>
            Wykorzystanie UPDATE zawiera: po pierwsze wybór tabeli, w której znajduje się pole,
            które chcemy zmienić, po drugie ustawienie w zapisie nowej wartości przy pomocy SET i po
            trzecie - wykorzystanie WHERE, aby oznaczyć konkretne miejsce w tabeli.
          </p>
          <p>
            W tabeli contacts jest u nas zapis z id = 5, w którym nie ma wartości pola user_id.
            Ustawmy, że właścicielem tego kontaktu będzie użytkownik Maksim z id = 3 w tabeli users.
          </p>
          <pre>
            UPDATE contacts SET user_id = 3 WHERE id = 5;
          </pre>
        </article>
        <article id="1.10">
          <h3>1.10 DELETE: Usuwanie zapisów z tabeli</h3>
          <p>
            Usuwanie zapisów z tabeli przez SQL jest również prostą operacją. Najważniejsze, aby
            zaznaczyć przy pomocy WHERE, co dokładnie chcemy usunąć. W przeciwnym razie usuniemy
            wszystkie zapisy z tabeli, czego chcielibyśmy uniknąć.
          </p>
          <pre>
            DELETE FROM contacts WHERE id = 4;
          </pre>
        </article>
        <article id="1.11">
          <h3>1.11 Usuwanie tabel</h3>
          <p>
            eżeli chcemy usunąć wszystkie dane z tabeli, a jednocześnie zostawić samą tabelę, to
            musimy użyć polecenia TRUNCATE:
          </p>
          <pre>
            TRUNCATE TABLE contacts;
          </pre>
          <p>Gdy chcemy usunąć samą tabelę, musimy użyć polecenia DROP:</p>
          <pre>
            DROP TABLE contacts;
          </pre>
        </article>
      </section>
      <!-- section2 -->
      <section id="2" class="text">
        <article id="2.1">
          <h2>2.1 Relacyjne bazy danych</h2>
        </article>
        <article id="2.2">
          <h3>2.2 Podstawy</h3>
          <p>
            Baza danych (BD), to zbiór z jednej i więcej tabel z danymi. Każda tabela zawiera
            informację w jednej i więcej kolumnach (polach). Jeden element danych (zapis) — to jeden
            łańcuch w tabeli.
          </p>
          <p>Klucz to unikalne pole, które jednoznacznie identyfikuje zapis.</p>
          <p>Primary key to unikalny klucz, który nie powtarza się w tabeli.</p>
          <p>
            Foreign key to odnośnik do unikalnego klucza, który NIE POWTARZA SIĘ w swojej tabeli.
          </p>
          <p>Relacje:</p>
          <ul class="unnumbered-list-container">
            <li>
              jeden do jednego — tabele są związane jeden do jednego wtedy, gdy jednemu łańcuchowi
              (zapisowi) tabeli A odpowiada jeden łańcuch tabeli B i jednemu zapisowi tabeli B
              odpowiada jeden zapis tabeli A;
            </li>
            <li>
              jeden do wielu — to połączenie w relacyjnych bazach danych realizuje się wtedy, gdy do
              jednego łańcucha tabeli A może należeć lub odpowiadać mu kilka zapisów w tabeli B, ale
              zapisowi z tabeli B może odpowiadać tylko jeden zapis tabeli A. Przykład: u
              użytkownika może być kilka numerów telefonicznych;
            </li>
            <li>
              wielu do wielu — realizuje się w tym przypadku, gdy kilku zapisom z tabeli A może
              odpowiadać kilka zapisów z tabeli B i w tym czasie kilku zapisom z tabeli B odpowiada
              kilka zapisów z tabeli A;
            </li>
            <li>
              wiele do jednego — odwrotna sytuacja jeden do wielu, ale teraz tabele A i B można
              zamienić miejscami.
            </li>
          </ul>
          <p>
            Normalizacja — proces doprowadzenia struktury BD do postaci zapewniającej minimalną
            logiczną redundancję i nie ma na celu zmniejszenia lub zwiększenia wydajności pracy lub
            zmniejszenia albo zwiększenia fizycznej objętości bazy danych. Ostatecznym celem
            normalizacji jest zmniejszenie potencjalnej niezgodności przechowywanych w bazie danych
            informacji.
          </p>
          <p>
            Podstawowy instrument komunikacji z relacyjnymi BD — SQL (Structured Query Language).
          </p>
          <p>SQL — język strukturyzowanych zapytań.</p>
        </article>
        <article id="2.3">
          <h3>2.3 Podstawowe operatory SQL:</h3>
          <ol class="numbered-list-container">
            <li>
              operatory definicji danych (Data Definition Language, DDL):
              <ul class="unnumbered-list-container">
                <li>CREATE tworzy obiekt BD (samą bazę, tabelę, widok, użytkownika itd.);</li>
                <li>ALTER zmienia obiekt;</li>
                <li>DROP usuwa obiekt.</li>
              </ul>
            </li>
            <li>
              operatory manipulacji danymi (Data Manipulation Language, DML):
              <ul class="unnumbered-list-container">
                <li>SELECT wybiera dane, spełniające określone warunki;</li>
                <li>INSERT dodaje nowe dane;</li>
                <li>UPDATE zmienia istniejące dane;</li>
                <li>DELETE usuwa dane.</li>
              </ul>
            </li>
            <li>
              operatory określania dostępu do danych (Data Control Language, DCL):
              <ul class="unnumbered-list-container">
                <li>
                  GRANT dostarcza użytkownikowi (grupie) pozwolenia na określone operacje z
                  obiektem;
                </li>
                <li>REVOKE odwołuje wcześniej wydane pozwolenia.</li>
              </ul>
            </li>
            <li>
              operatory zarządzania transakcjami (Transaction Control Language, TCL):
              <ul class="unnumbered-list-container">
                <li>COMMIT przyjmuje transakcję;</li>
                <li>
                  ROLLBACK odkrywa wszystkie zmiany wprowadzone w kontekście obecnej transakcji;
                </li>
                <li>SAVEPOINT dzieli transakcję na mniejsze części.</li>
              </ul>
            </li>
          </ol>
        </article>
        <article id="2.4">
          <h3>2.4 ER (Entity - relationship) - diagramy.</h3>
          <p>
            Modl ER — model danych, pozwalający opisywać konceptualne schematy danej dziedziny.
            Model ER wykorzystywany jest przy wysokopoziomowym (konceptualnym) projektowaniu baz
            danych. Z jego pomocą można wydzielić kluczowe podmioty i oznaczyć związki, które mogą
            utworzyć się między tymi podmiotami.
          </p>
          <div class="img-container grow_up-img">
            <img src="../images/node/63-baza-sql-3.png" alt="" />
          </div>
        </article>
        <article id="2.5">
          <h2>2.5 Podłączenie</h2>
          <p>
            Programów do pracy z bazami SQL jest dość dużo, ale rekomendujemy dwa:
            <a href="https://www.heidisql.com/">HeidiSQL</a> i
            <a href="https://dbeaver.io/">DBeaver</a>
            .
          </p>
          <p>
            Jako objaśnienie po podłączeniu będziemy wykorzystywać DBeaver, który pracuje z
            większością słynnych baz danych.
          </p>
          <p>
            Ściągamy ze strony sterowniki
            <a href="https://dbeaver.io/download/">https://dbeaver.io/download/</a> .
          </p>
          <p>
            Do uruchomienia bazy danych
            <a href="https://hub.docker.com/_/postgres">postgres</a> wykorzystujemy Docker. W
            łańcuchu polecenia należy wykonać takie polecenie:
          </p>
          <pre>
            docker run --name some-postgres -p 5432:5432 -e POSTGRES_PASSWORD=mysecretpassword -d postgres
          </pre>
          <p>
            Zamiast some-postgres wybierz swoją nazwę kontenera, a zamiast mysecretpassword wymyśl
            swoje hasło do podłączenia do bazy danych.
          </p>
          <p>Teraz możemy podłączyć się do naszej bazy.</p>
          <div class="img-container grow_up-img">
            <img src="../images/node/64-baza-sql-4.png" alt="" />
          </div>
          <p>
            Początkowe ustawienia powinny już być prawidłowe, w polu password wpisz hasło, które
            ustawiłeś.
          </p>
          <div class="img-container grow_up-img">
            <img src="../images/node/65-baza-sql-5.png" alt="" />
          </div>
          <p>Klikamy Test łączności... powinna wyskoczyć następująca wiadomość.</p>
          <div class="img-container grow_up-img">
            <img src="../images/node/66-baza-sql-6.png" alt="" />
          </div>
          <p>
            Jeżeli wszystko w porządku, na twojej liście pojawi się serwer, otwórz go, będzie to
            wyglądać jak na screenie poniżej:
          </p>
          <div class="img-container grow_up-img">
            <img src="../images/node/67-baza-sql-7.png" alt="" />
          </div>
          <p>Teraz mamy gotową bazę danych o nazwie postgres.</p>
          <p>
            Podłączenie do bazy danych SQLite jest jeszcze łatwiejsze. W gruncie rzeczy to plik
            lokalny, który należy utworzyć.
          </p>
          <div class="img-container grow_up-img">
            <img src="../images/node/68-baza-sql-8.png" alt="" />
          </div>
          <p>
            Zapisz ścieżkę i nazwę pliku tam, gdzie chcesz, aby zapisywał się nasz plik z bazą
            danych:
          </p>
          <div class="img-container grow_up-img">
            <img src="../images/node/69-baza-sql-9.png" alt="" />
          </div>
          <p>
            Jeżeli wszystko w porządku, na twojej liście pojawi się baza danych SQLite, otwórz ją,
            będzie to wyglądało jak na screenie poniżej:
          </p>
          <div class="img-container grow_up-img">
            <img src="../images/node/70-baza-sql-10.png" alt="" />
          </div>
        </article>
      </section>
      <!-- section3 -->
      <section id="3" class="text">
        <article id="3.1">
          <h2>3.1 Typy danych</h2>
        </article>
        <article id="3.2">
          <h3>3.2 Liczbowe typy danych</h3>
          <p>Liczby dzielą się na całkowite i rzeczywiste (liczba z kropką).</p>
        </article>
        <article id="3.3">
          <h3>3.3 Liczby całkowite</h3>
          <p>Liczby dzielą się na całkowite i rzeczywiste (liczba z kropką).</p>
          <table class="table-metody-odpowiedzi">
            <thead>
              <tr>
                <th>Typy</th>
                <th>Bajt</th>
                <th>Od</th>
                <th>Do</th>
                <th>Jeśli UNSIGNED</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>TINYINT</td>
                <td>1</td>
                <td>-128</td>
                <td>127</td>
                <td>255</td>
              </tr>
              <tr>
                <td>SMALLINT</td>
                <td>2</td>
                <td>-32768</td>
                <td>32767</td>
                <td>65535</td>
              </tr>
              <tr>
                <td>MEDIUMINT</td>
                <td>3</td>
                <td>-8388698</td>
                <td>8388607</td>
                <td>16777215</td>
              </tr>
              <tr>
                <td>INT</td>
                <td>4</td>
                <td>-2137483648</td>
                <td>2147483647</td>
                <td>4294967295</td>
              </tr>
              <tr>
                <td>BIGINT</td>
                <td>8</td>
                <td>-9223372036854775808</td>
                <td>9223372036854775807</td>
                <td>18446744073709551615</td>
              </tr>
            </tbody>
          </table>
          <p>Liczby całkowite dzieli się na typy:</p>
          <ul>
            <li>SIGNED - znakowe (jeden bit odchodzi na znak plus albo minus);</li>
            <li>
              UNSIGNED - bez znaków, jeżeli wartości są tylko dodatnie, na przykład odległość,
              powierzchnia i tak dalej. Zwiększyć dodatnią wartość dla typu dwa razy, to znaczy
              TINYINT UNSIGNED będzie 0 do 255.
            </li>
          </ul>
        </article>
        <article id="3.4">
          <h3>3.4 Liczby ułamkowe</h3>
          <p>Wszystkie liczby rzeczywiste w SQL mają ściśle określoną dokładność.</p>
          <p>Pseudonimy typu:</p>
          <ul>
            <li>REAL(10,2)</li>
            <li>DECIMAL(10,2)</li>
            <li>FIXED(10,2)</li>
            <li>FLOAT(10,2)</li>
          </ul>
          <p>
            Wszystkie te 4 funkcje to pseudonimy i nie ma zasadniczej różnicy między nimi w SQL, ale
            realizacje lepiej uściślić w dokumentacji.
          </p>
        </article>
        <article id="3.5">
          <h3>3.5 Typy danych: data i czas</h3>
          <table class="table-metody-odpowiedzi">
            <thead>
              <tr>
                <th>Typy</th>
                <th>Wartość</th>
                <th>Bajt</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>DATETIME</td>
                <td>0000-00-00 00:00:00</td>
                <td>8</td>
              </tr>
              <tr>
                <td>TIMESTAMP</td>
                <td>00000000000000</td>
                <td>4</td>
              </tr>
              <tr>
                <td>DATE</td>
                <td>0000-00-00</td>
                <td>3</td>
              </tr>
              <tr>
                <td>TIME</td>
                <td>00:00:00</td>
                <td>3</td>
              </tr>
              <tr>
                <td>YEAR</td>
                <td>0</td>
                <td>1</td>
              </tr>
            </tbody>
          </table>
          <p>Bardziej szczegółowo:</p>
          <ul>
            <li>
              DATETIME - dla pełnowymiarowej daty i czasu o dużej objętości, w przybliżeniu 4-8
              bajtów. Zapisuje się w postaci łańcucha i zawsze od większej wartości do mniejszej:
              rok, miesiąc, dzień, godziny, minuty, sekundy. Wspierany jest zakres od '1000-01-01
              00:00:00' do '9999-12-31 23:59:59'. Jeżeli potrzeba niżej, zapisujemy po prostu minus
              '-500-01-09 00:00:00'.
            </li>
            <li>
              TIMESTAMP - znacznik czasu, zakres ery Unixa 1970-01-01 00:00:00 — 2038-12-31
              00:00:00;
            </li>
            <li>DATE - to tylko data bez czasu;</li>
            <li>TIME - tylko czas;</li>
            <li>YEAR - tylko rok.</li>
          </ul>
        </article>
        <article id="3.6">
          <h2>3.6 Znakowe typy danych</h2>
        </article>
        <article id="3.7">
          <h3>3.7 Typy CHAR i VARCHAR</h3>
          <p>Te typy danych zapisują łańcuch określonej długości.</p>
          <p>
            CHAR - zapisuje symbole zawsze jednakowej długości, w ten sposób dla CHAR(10) zawsze
            będzie zapisane 10 znaków (nie bajtów). Jeżeli wprowadzona granica typu to 10, zawsze
            zapisane będzie 10. Jeżeli w łańcuchu nie wystarczy znaków, zostanie to uzupełnione
            spacjami, jeżeli znaków jest wiele, to zostaną ucięte.
          </p>
          <p>
            VARCHAR - to zmienny CHAR, u którego jest uzupełniający bajt symbolizujący koniec,
            innymi słowy znacznik końca. W ten sposób znaków będzie równo tyle, ile wprowadziliśmy
            plus 1 bajt. Znaczy to, że w przypadku CHAR(4) pusty łańcuch waży 4 bajty, a przy
            VARCHAR(4) waży 1 bajt, waga samego znacznika. W przypadku przepełnienia łańcuch także
            zostanie ucięty.
          </p>
          <p>Tabela porównująca:</p>
          <table class="table-metody-odpowiedzi">
            <thead>
              <tr>
                <th>Wielkość</th>
                <th>CHAR(4)</th>
                <th>Potrzebna pamięć</th>
                <th>VARCHAR(4)</th>
                <th>Potrzebna pamięć</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>''</td>
                <td>'                '</td>
                <td>4 bajty</td>
                <td>''</td>
                <td>1 bajt</td>
              </tr>
              <tr>
                <td>'ab'</td>
                <td>'ab        '</td>
                <td>4 bajty</td>
                <td>'ab'</td>
                <td>3 bajty</td>
              </tr>
              <tr>
                <td>'abcd'</td>
                <td>'abcd'</td>
                <td>4 bajty</td>
                <td>'abcd'</td>
                <td>5 bajtów</td>
              </tr>
              <tr>
                <td>'abcdefgh'</td>
                <td>'abcd'</td>
                <td>4 bajty</td>
                <td>'abcd'</td>
                <td>5 bajtów</td>
              </tr>
            </tbody>
          </table>
          <p>
            Jaki jest powód korzystania z CHAR, jeśli VARCHAR jest dużo wygodniejszy? Problem nie
            polega na oszczędzaniu miejsca, 1 bajt w milionowych tabelach da wiele miejsca.
            Najważniejsze, że wyszukiwanie po CHAR działa dużo szybciej. Jeżeli nasza wartość jest
            jawna i nie może być większa, jak np. numer telefonu, paszportu itd., nie ma sensu
            wykorzystywanie typu VARCHAR, ponieważ spowolnimy bazę i stracimy po bajcie na zapis.
          </p>
          <p>Załóżmy, że istnieją łańcuchy CHAR(3), które zapiszemy w bazie.</p>
          <table class="table-metody-odpowiedzi">
            <thead>
              <tr>
                <th>code</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>abc</td>
              </tr>
              <tr>
                <td>bac</td>
              </tr>
              <tr>
                <td>cab</td>
              </tr>
            </tbody>
          </table>
          <p>W bazie będą one przechowywane mniej więcej tak:</p>
          <pre>
            abc bac cab
          </pre>
          <p>
            Jeżeli chcemy otrzymać trzeci zapis, to baza dokładnie wie, że ilość znaków w bazie
            wynosi po 3 i po prostu zacznie czytać od siódmego znaku. Jeżeli byłby to VARCHAR(3), w
            tej strukturze baza musiałaby przejrzeć wszystkie zapisu, aby wyszukać ich znaczniki
            końca zapisu. Nie może ona już przejrzeć 6 symboli, ponieważ łańcuchy mogą nie być pełne
            i mieć różną długość.
          </p>
        </article>
        <article id="3.8">
          <h3>3.8 Typy danych TEXT</h3>
          <p>
            To typy do przechowywania dużego tekstu oprócz TINYTEXT - to synonim VARCHAR. Jeżeli
            potrzebujemy zapisać opis, odpowiedzi lub nawet książki, to jest to potrzebny typ.
          </p>
          <p>TEXT - wykorzystywany jest najczęściej z tych typów.</p>
        </article>
      </section>
    </main>
    <footer class="footer">
      <div class="footer-logo">
        <img src="../images/footer/konikMaly24x24Squoosh.png" alt="logoImage" width="24" />
        <img src="../images/footer/3KLogo.png" alt="logoText" />
      </div>
      <div id="footer-title">
        <p></p>
      </div>
      <div class="footer-date">
        <p>28.12.2024r.</p>
      </div>
    </footer>
    <!-- SKRYPTY JS -->
    <script defer src="../scripts/menuNode.mjs"></script>
  </body>
</html>
